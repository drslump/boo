{
    "docs": [
        {
            "location": "/", 
            "text": "Boo is an object oriented statically typed programming language for the .NET and Mono\nruntimes with a python inspired syntax and a special focus on language and compiler\nextensibility.\n\n\nA good way to start is by reading the \nBoo Manifesto\n and following\nthe \nPrimer\n to learn the language step by step.\n\n\n\n\nNote\n\n\nThe Boo Primer is also available in \nTraditional Chinese\n (\u7e41\u9ad4\u4e2d\u6587), translated by Yan-ren Tsai aka Elleryq.\n\n\nThe english version is downloadable in \nPDF format\n.\n\n\n\n\nFor a more detailed explanation about the features in the language check out the \nLanguage Guide\n.", 
            "title": "Home"
        }, 
        {
            "location": "/Primer/Starting-Out/", 
            "text": "Boo is an amazing language that combines the syntactic sugar of \nPython\n,\nthe features of \nRuby\n, and the speed and safety of\n\nC#\n.\n\n\nLike C#, Boo is a statically-typed language, which means that types are important. This adds a\ndegree of safety that Python and other dynamically-typed languages do not currently provide.\n\n\nIt fakes being a dynamically-typed language by inference. This makes it seem much like Python's\nsimple and programmer-friendly syntax.\n\n\nint i = 0;\nMyClass m = new MyClass();\n\n\n\n\ni = 0\nm = MyClass()\n\n\n\n\nHello, World!\n\n\nA \nHello, World!\n program is very simple in Boo.\n\n\nDon't worry if you don't understand it, I'll go through it one step at a time.\n\n\nprint \nHello, World!\n\n//    OR\nprint(\nHello, World!\n)\n\n\n\n\nOutput:\n\n\nHello, World!\nHello, World!\n\n\n\n\n\nFirst, you must compile the helloworld.boo file to an executable.\n\n\nOpen up a new \ncommand line\n\n\ncd\n into the directory where you placed the \nhelloworld.boo\n file.\n\n\nbooc helloworld.boo\n (this assumes that Boo is installed and in your \nsystem path\n)\n\n\nhelloworld.exe\n\n\nIf you are using \nMono\n, \nmono helloworld.exe\n\n\nUsing the print macro, it prints the string \"Hello, World!\" to the screen. OR\n\n\nUsing the print function, it prints the string \"Hello, World!\" to the screen.\n\n\n\n\nNow these both in the end, do the same thing. They both call \nSystem.Console.WriteLine(\"Hello, World\")\n\nfrom the .NET Standard Library.\n\n\n\n\nHint\n\n\nUsing the macro version \nprint \"Hello, World!\"\n is recommended.\n\n\n\n\nAnd it's that simple.\n\n\nComparing code between Boo, C#, and VB.NET\n\n\nNow you may be wondering how Boo could be as fast as C# or VB.NET.\n\n\nUsing their Hello World programs, I'll show you.\n\n\nBoo:\n\n\nprint \nHello World!\n\n\n// Output: Hello World!\n\n\n\n\nCSharp:\n\n\npublic class Hello\n{\n  public static void Main()\n  {\n    System.Console.WriteLine(\nHello World!\n);\n  }\n}\n\n// Output: Hello World!\n\n\n\n\nVB.NET:\n\n\nPublic Class Hello\n  Public Shared Sub Main()\n    System.Console.WriteLine(\nHello World!\n)\n  End Sub\nEnd Class\n\n' Output: Hello World!\n\n\n\n\nAll three have the same end result and all three are run in the .NET Framework.\n\n\nAll three are first translated into MSIL, then into executable files.\n\n\n\n\nIf you were to take the executables created by their compilers, and disassemble them with\n\nildasm.exe\n, you would see a very similar end result, which means that the executables\nthemselves are very similar, so the speed between C# and Boo is practically the same, it\njust takes less time to write the Boo code.\n\n\nBooish\n\n\nbooish\n is a command line utility that provides a realtime environment to code boo in. It\nis great for testing purposes, and I recommend following along for the next few pages by\ntrying out a few things in \nbooish\n.\n\n\nYou can invoke it by loading up a terminal, then typing booish (this assumes that Boo is\ninstalled and in your system path), or by double-clicking the booish icon. In \nbooish\n, you\ncan up arrow to re-enter (with editing) a previously entered line.\n\n\nHere's what \nbooish\n will look like:\n\n\n print \"Hello, World!\"\nHello, World!\n\n\n\n\n\nExercises\n\n\n\n\nWrite a Boo program that prints \nHello, World!\n, then prints \nGoodbye, World!\n\n\nPlay around with \nbooish\n\n\nAdvanced: Compile the Hello, World! programs for Boo (using \nbooc\n) and C#\n   (using \ncsc\n or \nmcs\n), run \nildasm\n on each of them and compare the result.", 
            "title": "Starting Out"
        }, 
        {
            "location": "/Primer/Starting-Out/#hello-world", 
            "text": "A  Hello, World!  program is very simple in Boo.  Don't worry if you don't understand it, I'll go through it one step at a time.  print  Hello, World! \n//    OR\nprint( Hello, World! )  Output:  Hello, World!\nHello, World!   First, you must compile the helloworld.boo file to an executable.  Open up a new  command line  cd  into the directory where you placed the  helloworld.boo  file.  booc helloworld.boo  (this assumes that Boo is installed and in your  system path )  helloworld.exe  If you are using  Mono ,  mono helloworld.exe  Using the print macro, it prints the string \"Hello, World!\" to the screen. OR  Using the print function, it prints the string \"Hello, World!\" to the screen.   Now these both in the end, do the same thing. They both call  System.Console.WriteLine(\"Hello, World\") \nfrom the .NET Standard Library.   Hint  Using the macro version  print \"Hello, World!\"  is recommended.   And it's that simple.", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/Primer/Starting-Out/#comparing-code-between-boo-c-and-vbnet", 
            "text": "Now you may be wondering how Boo could be as fast as C# or VB.NET.  Using their Hello World programs, I'll show you.  Boo:  print  Hello World! \n\n// Output: Hello World!  CSharp:  public class Hello\n{\n  public static void Main()\n  {\n    System.Console.WriteLine( Hello World! );\n  }\n}\n\n// Output: Hello World!  VB.NET:  Public Class Hello\n  Public Shared Sub Main()\n    System.Console.WriteLine( Hello World! )\n  End Sub\nEnd Class\n\n' Output: Hello World!  All three have the same end result and all three are run in the .NET Framework.  All three are first translated into MSIL, then into executable files.   If you were to take the executables created by their compilers, and disassemble them with ildasm.exe , you would see a very similar end result, which means that the executables\nthemselves are very similar, so the speed between C# and Boo is practically the same, it\njust takes less time to write the Boo code.", 
            "title": "Comparing code between Boo, C#, and VB.NET"
        }, 
        {
            "location": "/Primer/Starting-Out/#booish", 
            "text": "booish  is a command line utility that provides a realtime environment to code boo in. It\nis great for testing purposes, and I recommend following along for the next few pages by\ntrying out a few things in  booish .  You can invoke it by loading up a terminal, then typing booish (this assumes that Boo is\ninstalled and in your system path), or by double-clicking the booish icon. In  booish , you\ncan up arrow to re-enter (with editing) a previously entered line.  Here's what  booish  will look like:   print \"Hello, World!\"\nHello, World!", 
            "title": "Booish"
        }, 
        {
            "location": "/Primer/Starting-Out/#exercises", 
            "text": "Write a Boo program that prints  Hello, World! , then prints  Goodbye, World!  Play around with  booish  Advanced: Compile the Hello, World! programs for Boo (using  booc ) and C#\n   (using  csc  or  mcs ), run  ildasm  on each of them and compare the result.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Variables/", 
            "text": "Using Booish as a Calculator\n\n\nThere are four basic mathematical operators: addition \n+\n, subtraction \n-\n, multiplication \n*\n, and \ndivision \n/\n. There are more than just these, but that's what will be covered now.\n\n\n    $ booish\n    \n 2 + 4 // This is a comment\n    6\n    \n 2 * 4 # So is this also a comment\n    8\n    \n 4 / 2 /* This is also a comment */\n    2\n    \n (500/10)*2\n    100\n    \n 7 / 3 // Integer division\n    2\n    \n 7 % 3 // Take the remainder\n    1\n    \n -7 / 3\n    -2\n\n\n\n\nYou may have noticed that there are 3 types of comments available, \n//\n, \n#\n, and \n/* */\n. These do\nnot cause any affect whatsoever, but help you when writing your code.\n\n\n\n\nHint\n\n\nWhen doing single-line comments, use \n//\n instead of \n#\n\n\n\n\nYou may have noticed that 7 / 3 did not give 2.333..., this is because you were dividing two integers together.\n\n\n\n\nNote\n\n\nInteger\n - Any positive or negative number that does not include a fraction or decimal,\nincluding zero.\n\n\n\n\nThe way computers handle integer division is by rounding to the floor afterwards.\n\n\nIn order to have decimal places, you must use a floating-point number.\n\n\n\n\nNote\n\n\nFloating point Number\n - Often referred to in mathematical terms as a \"rational\" number,\nthis is just a number that can have a fractional part.\n\n\n\n\n    $ booish\n    \n 7.0 / 3.0 // Floating point division\n    2.33333333333333\n    \n -8.0 / 5.0\n    -1.6\n\n\n\n\nIf you give a number with a decimal place, even if it's .0, it become a floating-point number.\n\n\nTypes of Numbers\n\n\nThere are 3 kinds of floating point numbers, \nsingle\n, \ndouble\n, and \ndecimal\n.\n\n\nThe differences between \nsingle\n and \ndouble\n is the size they take up. \ndouble\n is prefered in most situations.\n\n\nThese two also are based on the number 2, which can cause some problems when working with our base-10 number system.\n\n\nUsusally this is not the case, but in delecate situations like banking, it would not be wise to lose a cent or two\non a multi-trillion dollar contract.\n\n\nThus \ndecimal\n was created. It is a base-10 number, which means that we wouldn't lose that precious penny.\n\n\nIn normal situations, \ndouble\n is perfectly fine. For a higher precision, a \ndecimal\n should be used.\nIntegers, which we covered earlier, have many more types to them.\n\n\nThey also have the possibility to be \"unsigned\", which means that they must be non-negative.\n\n\nThe size goes in order as such: \nbyte\n, \nshort\n, \nint\n, and \nlong\n.\n\n\nIn most cases, you will be using \nint\n, which is the default.\n\n\nCharacters and Strings\n\n\n\n\nNote\n\n\nCharacter\n - A written symbol that is used to represent speech.\n\n\n\n\nAll the letters in the alphabet are characters. All the numbers are characters. All the symbols\nof the Mandarin language are characters. All the mathematical symbols are characters.\n\n\nIn Boo/.NET, characters are internally encoded as UTF-16, or \nUnicode\n.\n\n\n\n\nNote\n\n\nString\n - A linear sequence of characters.\n\n\n\n\nThe word \"apple\" can be represented by a \nstring\n.\n\n\n    $ booish\n    \n s = \napple\n\n    'apple'\n    \n print s\n    apple\n    \n s += \n banana\n\n    'apple banana'\n    \n print s\n    apple banana\n    \n c = char('C')\n    C\n    \n print c\n    C\n\n\n\n\nNow you probably won't be using \nchars\n much, it is more likely you will be using \nstrings\n.\n\n\nTo declare a \nstring\n, you have one of three ways.\n\n\n\n\nusing double quotes. \"apple\"\n\n\nusing single quotes. 'apple'\n\n\nusing tripled double quotes. \"\"\"apple\"\"\"\n\n\n\n\nThe first two can span only one line, but the tribbled double quotes can span multiple lines.\n\n\nThe first two also can have backslash-escaping. The third takes everything literally.\n\n\n    $ booish\n    \n print \napple\\nbanana\n\n    apple\n    banana\n    \n print 'good\\ttimes'\n    good      times\n    \n print \nLeeroy\\Jenkins\n\n    Leeroy\\Jenkins\n\n\n\n\nCommon escapes are:\n\n\n\n\n{{ ... }} literal backslash\n\n\n\\n newline\n\n\n\\r carriage return\n\n\n\\t tab\n\n\n\n\nIf you are declaring a double-quoted \nstring\n, and you want a double quote inside it, also use a backslash.\n\n\nSame goes for the single-quoted \nstring\n.\n\n\n    $ booish\n    \n print \nThe man said \\\nHello\\\n\n    The man said \nHello\n\n    \n print 'I\\'m happy'\n    I'm happy\n\n\n\n\nstrings\n are immutable, which means that the characters inside them can never change. You would have to\nrecreate the \nstring\n to change a \ncharacter\n.\n\n\n\n\nNote\n\n\nImmutable\n - Not capable of being modified after it is created. It is an error to\nattempt to modify an immutable object. The opposite of immutable is mutable.\n\n\n\n\nString Interpolation\n\n\nString interpolation allows you to insert the value of almost any valid boo expression inside a \nstring\n\nby preceeding a lonesome variable name with $, or quoting an expression with $().\n\n\n    $ booish\n    \n name = \nSanta Claus\n\n    Santa Claus\n    \n print \nHello, $name!\n\n    Hello, Santa Claus!\n    \n print \n2 + 2 = $(2 + 2)\n\n    2 + 2 = 4\n\n\n\n\n\n\nHint\n\n\nString Interpolation is the preferred way of adding \nstrings\n together. It is preferred over\nsimple \nstring\n addition.\n\n\n\n\nString Interpolation can function in double-quoted \nstrings\n, including tripled double-quoted \nstring\n.\n\n\nIt does not work in single-quoted \nstrings\n.\n\n\nTo stop String Interpolation from happening, just escape the dollar sign: \\${} or alternatively use\nbacktick quoted strings:\n\n\nprint `not $interpolated!`\n\n\n\n\nBooleans\n\n\n\n\nNote\n\n\nBoolean\n - A value of \ntrue\n or \nfalse\n represented internally in binary notation.\n\n\n\n\nBoolean values can only be \ntrue\n or \nfalse\n, which is very handy for conditional statements, covered in\nthe next section.\n\n\n    $ booish\n    \n b = true\n    true\n    \n print b\n    True\n    \n b = false\n    false\n    \n print b\n    False\n\n\n\n\nObject Type\n\n\n\n\nNote\n\n\nObject\n - The central concept in the object-oriented programming paradigm.\n\n\n\n\nEverything in Boo/.NET is an object.\n\n\nAlthough some are value types, like numbers and characters, these are still objects.\n\n\n    $ booish\n    \n o as object\n    \n o = 'string'\n    'string'\n    \n print o\n    string\n    \n o = 42\n    42\n    \n print o\n    42\n\n\n\n\nThe problem with \nobjects\n is that you can't implicitly expect a \nstring\n or an \nint\n.\n\n\nIf I were to do that same sequence without declaring \no as object\n,\n\n\n    $ booish\n    \n o = 'string'\n    'string'\n    \n print o\n    string\n    \n o = 42\n    --------^\n    ERROR: Cannot convert 'System.Int32' to 'System.String'.\n\n\n\n\nThis static typing keeps the code safe and reliable.\n\n\nDeclaring a Type\n\n\nIn the last section, you issued the statement \no as object\n.\n\n\nThis can work with any type and goes with the syntax \nvariable\n as \ntype\n.\n\n\ntype\n can be anything from an \nint\n to a \nstring\n to a \ndate\n to a \nbool\n to something which\nyou defined yourself, but those will be discussed later.\nIn most cases, Boo will be smart and implicitly figure out what you wanted.\n\n\nThe code \ni = 25\n is the same thing as \ni as int = 25\n, just easier on your wrists.\n\n\n\n\nHint\n\n\nUnless you are declaring a variable beforehand, or declaring it of a different type,\ndon't explicitly state what kind of variable it is. (ie: use \ni = 25\n instead of\n\ni as int = 25\n)\n\n\n\n\nList of Value Types\n\n\n\n\n\n\n Boo type \n\n\n .NET Framework type \n\n\n Signed? \n\n\n Size in bytes \n\n\n Possible Values \n\n\n\n\n\n\n sbyte \n\n\n System.Sbyte \n\n\n Yes \n\n\n 1 \n\n\n -128 to 127 \n\n\n\n\n\n\n short \n\n\n System.Int16 \n\n\n Yes \n\n\n 2 \n\n\n -32768 - 32767 \n\n\n\n\n\n\n int \n\n\n System.Int32 \n\n\n Yes \n\n\n 4 \n\n\n -2147483648 - 2147483647 \n\n\n\n\n\n\n long \n\n\n System.Int64 \n\n\n Yes \n\n\n 8 \n\n\n -9223372036854775808 - 9223372036854775807 \n\n\n\n\n\n\n byte \n\n\n System.Byte \n\n\n No \n\n\n 1 \n\n\n 0 - 255 \n\n\n\n\n\n\n ushort \n\n\n System.Uint16 \n\n\n No \n\n\n 2 \n\n\n 0 - 65535 \n\n\n\n\n\n\n uint \n\n\n System.UInt32 \n\n\n No \n\n\n 4 \n\n\n 0 - 4294967295 \n\n\n\n\n\n\n ulong \n\n\n System.Uint64 \n\n\n No \n\n\n 8 \n\n\n 0 - 18446744073709551615 \n\n\n\n\n\n\n single \n\n\n System.Single \n\n\n Yes \n\n\n 4 \n\n\n Approximately \n1.5 x 10-45 - \n3.4 x 1038 with 7 significant figures \n\n\n\n\n\n\n double \n\n\n System.Double \n\n\n Yes \n\n\n 8 \n\n\n Approximately \n5.0 x 10-324 - \n1.7 x 10308 with 15 or 16 significant figures \n\n\n\n\n\n\n decimal \n\n\n System.Decimal \n\n\n Yes \n\n\n 12 \n\n\n Approximately \n1.0 x 10-28 - \n7.9 x 1028 with 28 or 29 significant figures \n\n\n\n\n\n\n char \n\n\n System.Char \n\n\n N/A \n\n\n 2 \n\n\n Any UTF-16 character \n\n\n\n\n\n\n bool \n\n\n System.Boolean \n\n\n N/A \n\n\n 1 \n\n\n true or false \n\n\n\n\n\n\n\n\n\nHint\n\n\nNever call a type by its .NET Framework type, use the builtin boo types.\n\n\n\n\nExercises\n\n\n\n\nDeclare some variables. Go wild.", 
            "title": "Variables"
        }, 
        {
            "location": "/Primer/Variables/#using-booish-as-a-calculator", 
            "text": "There are four basic mathematical operators: addition  + , subtraction  - , multiplication  * , and \ndivision  / . There are more than just these, but that's what will be covered now.      $ booish\n      2 + 4 // This is a comment\n    6\n      2 * 4 # So is this also a comment\n    8\n      4 / 2 /* This is also a comment */\n    2\n      (500/10)*2\n    100\n      7 / 3 // Integer division\n    2\n      7 % 3 // Take the remainder\n    1\n      -7 / 3\n    -2  You may have noticed that there are 3 types of comments available,  // ,  # , and  /* */ . These do\nnot cause any affect whatsoever, but help you when writing your code.   Hint  When doing single-line comments, use  //  instead of  #   You may have noticed that 7 / 3 did not give 2.333..., this is because you were dividing two integers together.   Note  Integer  - Any positive or negative number that does not include a fraction or decimal,\nincluding zero.   The way computers handle integer division is by rounding to the floor afterwards.  In order to have decimal places, you must use a floating-point number.   Note  Floating point Number  - Often referred to in mathematical terms as a \"rational\" number,\nthis is just a number that can have a fractional part.       $ booish\n      7.0 / 3.0 // Floating point division\n    2.33333333333333\n      -8.0 / 5.0\n    -1.6  If you give a number with a decimal place, even if it's .0, it become a floating-point number.", 
            "title": "Using Booish as a Calculator"
        }, 
        {
            "location": "/Primer/Variables/#types-of-numbers", 
            "text": "There are 3 kinds of floating point numbers,  single ,  double , and  decimal .  The differences between  single  and  double  is the size they take up.  double  is prefered in most situations.  These two also are based on the number 2, which can cause some problems when working with our base-10 number system.  Ususally this is not the case, but in delecate situations like banking, it would not be wise to lose a cent or two\non a multi-trillion dollar contract.  Thus  decimal  was created. It is a base-10 number, which means that we wouldn't lose that precious penny.  In normal situations,  double  is perfectly fine. For a higher precision, a  decimal  should be used.\nIntegers, which we covered earlier, have many more types to them.  They also have the possibility to be \"unsigned\", which means that they must be non-negative.  The size goes in order as such:  byte ,  short ,  int , and  long .  In most cases, you will be using  int , which is the default.", 
            "title": "Types of Numbers"
        }, 
        {
            "location": "/Primer/Variables/#characters-and-strings", 
            "text": "Note  Character  - A written symbol that is used to represent speech.   All the letters in the alphabet are characters. All the numbers are characters. All the symbols\nof the Mandarin language are characters. All the mathematical symbols are characters.  In Boo/.NET, characters are internally encoded as UTF-16, or  Unicode .   Note  String  - A linear sequence of characters.   The word \"apple\" can be represented by a  string .      $ booish\n      s =  apple \n    'apple'\n      print s\n    apple\n      s +=   banana \n    'apple banana'\n      print s\n    apple banana\n      c = char('C')\n    C\n      print c\n    C  Now you probably won't be using  chars  much, it is more likely you will be using  strings .  To declare a  string , you have one of three ways.   using double quotes. \"apple\"  using single quotes. 'apple'  using tripled double quotes. \"\"\"apple\"\"\"   The first two can span only one line, but the tribbled double quotes can span multiple lines.  The first two also can have backslash-escaping. The third takes everything literally.      $ booish\n      print  apple\\nbanana \n    apple\n    banana\n      print 'good\\ttimes'\n    good      times\n      print  Leeroy\\Jenkins \n    Leeroy\\Jenkins  Common escapes are:   {{ ... }} literal backslash  \\n newline  \\r carriage return  \\t tab   If you are declaring a double-quoted  string , and you want a double quote inside it, also use a backslash.  Same goes for the single-quoted  string .      $ booish\n      print  The man said \\ Hello\\ \n    The man said  Hello \n      print 'I\\'m happy'\n    I'm happy  strings  are immutable, which means that the characters inside them can never change. You would have to\nrecreate the  string  to change a  character .   Note  Immutable  - Not capable of being modified after it is created. It is an error to\nattempt to modify an immutable object. The opposite of immutable is mutable.", 
            "title": "Characters and Strings"
        }, 
        {
            "location": "/Primer/Variables/#string-interpolation", 
            "text": "String interpolation allows you to insert the value of almost any valid boo expression inside a  string \nby preceeding a lonesome variable name with $, or quoting an expression with $().      $ booish\n      name =  Santa Claus \n    Santa Claus\n      print  Hello, $name! \n    Hello, Santa Claus!\n      print  2 + 2 = $(2 + 2) \n    2 + 2 = 4   Hint  String Interpolation is the preferred way of adding  strings  together. It is preferred over\nsimple  string  addition.   String Interpolation can function in double-quoted  strings , including tripled double-quoted  string .  It does not work in single-quoted  strings .  To stop String Interpolation from happening, just escape the dollar sign: \\${} or alternatively use\nbacktick quoted strings:  print `not $interpolated!`", 
            "title": "String Interpolation"
        }, 
        {
            "location": "/Primer/Variables/#booleans", 
            "text": "Note  Boolean  - A value of  true  or  false  represented internally in binary notation.   Boolean values can only be  true  or  false , which is very handy for conditional statements, covered in\nthe next section.      $ booish\n      b = true\n    true\n      print b\n    True\n      b = false\n    false\n      print b\n    False", 
            "title": "Booleans"
        }, 
        {
            "location": "/Primer/Variables/#object-type", 
            "text": "Note  Object  - The central concept in the object-oriented programming paradigm.   Everything in Boo/.NET is an object.  Although some are value types, like numbers and characters, these are still objects.      $ booish\n      o as object\n      o = 'string'\n    'string'\n      print o\n    string\n      o = 42\n    42\n      print o\n    42  The problem with  objects  is that you can't implicitly expect a  string  or an  int .  If I were to do that same sequence without declaring  o as object ,      $ booish\n      o = 'string'\n    'string'\n      print o\n    string\n      o = 42\n    --------^\n    ERROR: Cannot convert 'System.Int32' to 'System.String'.  This static typing keeps the code safe and reliable.", 
            "title": "Object Type"
        }, 
        {
            "location": "/Primer/Variables/#declaring-a-type", 
            "text": "In the last section, you issued the statement  o as object .  This can work with any type and goes with the syntax  variable  as  type .  type  can be anything from an  int  to a  string  to a  date  to a  bool  to something which\nyou defined yourself, but those will be discussed later.\nIn most cases, Boo will be smart and implicitly figure out what you wanted.  The code  i = 25  is the same thing as  i as int = 25 , just easier on your wrists.   Hint  Unless you are declaring a variable beforehand, or declaring it of a different type,\ndon't explicitly state what kind of variable it is. (ie: use  i = 25  instead of i as int = 25 )", 
            "title": "Declaring a Type"
        }, 
        {
            "location": "/Primer/Variables/#list-of-value-types", 
            "text": "Boo type    .NET Framework type    Signed?    Size in bytes    Possible Values      sbyte    System.Sbyte    Yes    1    -128 to 127      short    System.Int16    Yes    2    -32768 - 32767      int    System.Int32    Yes    4    -2147483648 - 2147483647      long    System.Int64    Yes    8    -9223372036854775808 - 9223372036854775807      byte    System.Byte    No    1    0 - 255      ushort    System.Uint16    No    2    0 - 65535      uint    System.UInt32    No    4    0 - 4294967295      ulong    System.Uint64    No    8    0 - 18446744073709551615      single    System.Single    Yes    4    Approximately  1.5 x 10-45 -  3.4 x 1038 with 7 significant figures      double    System.Double    Yes    8    Approximately  5.0 x 10-324 -  1.7 x 10308 with 15 or 16 significant figures      decimal    System.Decimal    Yes    12    Approximately  1.0 x 10-28 -  7.9 x 1028 with 28 or 29 significant figures      char    System.Char    N/A    2    Any UTF-16 character      bool    System.Boolean    N/A    1    true or false      Hint  Never call a type by its .NET Framework type, use the builtin boo types.", 
            "title": "List of Value Types"
        }, 
        {
            "location": "/Primer/Variables/#exercises", 
            "text": "Declare some variables. Go wild.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Conditionals/", 
            "text": "If Statement\n\n\n\n\nNote\n\n\nif statement\n - A control statement that contains one or more Boolean expressions whose results determine whether to execute other statements within the If statement.\n\n\n\n\nAn \nif\n statement allows you to travel down multiple logical paths, depending on a condition given. If the condition given is \ntrue\n, the block of code associated with it will be run.\n\n\ni = 5\nif i == 5:\n    print \ni is equal to 5.\n\n\n// Output: i is equal to 5.\n\n\n\n\n\n\nWarning\n\n\nBe careful\n notice the difference between \ni = 5\n and \ni == 5\n. The former is an \nassignment\n\nwhile the latter is a \ncomparison\n. If you try an assignment while running a conditional, Boo will\nemit a warning.\n\n\n\n\nYou may have noticed that unlike other languages, there is no then-endif or do-end or braces { }. Blocks\nof code are determined in Boo by its indentation. By this, your code blocks will always be noticeable and\nreadable.\n\n\n\n\nHint\n\n\nAlways use tabs for indentation.  In your editor, set the tab-size to view as 4 spaces.\n\n\n\n\nYou can have multiple code blocks within eachother as well.\n\n\nMultiple if statements\n\n\ni = 5\nif i \n 0:\n    print \ni is greater than 0.\n\n    if i \n 10:\n        print \ni is less than 10.\n\n        if i \n 5:\n            print \ni is greater than 5.\n\n\n// Output: i is greater than 0.\n//         i is less than 10.\n\n\n\n\nIf-Else Statement\n\n\nWith the \nif\n statement comes the \nelse\n statement. It is called when your \nif\n statement's condition is \nfalse\n.\n\n\ni = 5\nif i \n 5:\n    print \ni is greater than 5.\n\nelse:\n    print \ni is less than or equal to 5.\n\n\n// Output: i is less than or equal to 5.\n\n\n\n\nQuite simple.\n\n\nIf-Elif-Else Statement\n\n\nNow \nif\n you want to check for a condition after your \nif\n is \nfalse\n, that is easy as well.\nThis is done through the \nelif\n statement.\n\n\ni = 5\nif i \n 5:\n    print \ni is greater than 5.\n\nelif i == 5:\n    print \ni is equal to 5.\n\nelif i \n 5:\n    print \ni is less than 5.\n\n\n// Output: i is equal to 5.\n\n\n\n\nYou can have one \nif\n, any number of \nelif\n s, and an optional \nelse\n.\n\n\nUnless Statement\n\n\nThe \nunless\n statement is handy if you want a readable way of checking if a condition is \nnot\n true.\n\n\ni = 5\nunless i == 5:\n    print \ni is not equal to 5.\n\n\n// Output: \n\n\n\n\nIt didn't output because i was equal to 5 in that case.\n\n\nStatement with Modifier\n\n\nLike in Ruby and Perl, you can follow a statement with a modifier.\n\n\ni = 0\nprint i\ni = 5 if true\nprint i\ni = 10 unless true\nprint i\n\n// Output: 0\n//         5\n//         5\n\n\n\n\n\n\nHint\n\n\nDon't use Statement with Modifier on a long line. In that case, you should just create a code block.\nA good rule of thumb is to not use it if the statement is more than 3 words long. This will keep your\ncode readable and beautiful.\n\n\n\n\nSome common conditionals:\n\n\n\n\n\n\n Operator \n\n\n Meaning \n\n\n Example \n\n\n\n\n\n\n \n==\n \n\n\n equal \n\n\n \n5 == 5\n \n\n\n\n\n\n\n \n!=\n \n\n\n not equal \n\n\n \n0 != 5\n \n\n\n\n\n\n\n \n \n\n\n greater than \n\n\n \n4 \n 2\n \n\n\n\n\n\n\n \n \n\n\n less than \n\n\n \n2 \n 4\n \n\n\n\n\n\n\n \n=\n \n\n\n greater than or equal to \n\n\n \n7 \n= 7 and 7 \n= 4\n \n\n\n\n\n\n\n \n=\n \n\n\n less than or equal to \n\n\n \n4 \n= 8 and 6 \n= 6\n \n\n\n\n\n\n\n\nNot Condition\n\n\nTo check if a condition is not true, you would use \nnot\n.\n\n\ni = 0\nif not i \n 5:\n    print \ni is not greater than 5\n\n\n// Output: i is not greater than 5\n\n\n\n\nCombining Conditions\n\n\nTo check more than one condition, you would use \nand\n or \nor\n. Use parentheses ( ) to change the order of operations.\n\n\ni = 5\nif i \n 0 and i \n 10:\n    print \ni is between 0 and 10.\n\nif i \n 3 or i \n 7:\n    print \ni is not between 3 and 7.\n\nif (i \n 0 and i \n 3) or (i \n 7 and i \n 10):\n    print \ni is either between 0 and 3 or between 7 and 10.\n\n\n// Output: i is between 0 and 10.\n\n\n\n\nNote that \nand\n requires that both comparisons are true, while \nor\n requires that only one is true or both are true.\n\n\nExercises\n\n\n\n\nGiven the numbers x = 4, y = 8, and z = 6, compare them and print the middle one.", 
            "title": "Conditionals"
        }, 
        {
            "location": "/Primer/Conditionals/#if-statement", 
            "text": "Note  if statement  - A control statement that contains one or more Boolean expressions whose results determine whether to execute other statements within the If statement.   An  if  statement allows you to travel down multiple logical paths, depending on a condition given. If the condition given is  true , the block of code associated with it will be run.  i = 5\nif i == 5:\n    print  i is equal to 5. \n\n// Output: i is equal to 5.   Warning  Be careful  notice the difference between  i = 5  and  i == 5 . The former is an  assignment \nwhile the latter is a  comparison . If you try an assignment while running a conditional, Boo will\nemit a warning.   You may have noticed that unlike other languages, there is no then-endif or do-end or braces { }. Blocks\nof code are determined in Boo by its indentation. By this, your code blocks will always be noticeable and\nreadable.   Hint  Always use tabs for indentation.  In your editor, set the tab-size to view as 4 spaces.   You can have multiple code blocks within eachother as well.  Multiple if statements  i = 5\nif i   0:\n    print  i is greater than 0. \n    if i   10:\n        print  i is less than 10. \n        if i   5:\n            print  i is greater than 5. \n\n// Output: i is greater than 0.\n//         i is less than 10.", 
            "title": "If Statement"
        }, 
        {
            "location": "/Primer/Conditionals/#if-else-statement", 
            "text": "With the  if  statement comes the  else  statement. It is called when your  if  statement's condition is  false .  i = 5\nif i   5:\n    print  i is greater than 5. \nelse:\n    print  i is less than or equal to 5. \n\n// Output: i is less than or equal to 5.  Quite simple.", 
            "title": "If-Else Statement"
        }, 
        {
            "location": "/Primer/Conditionals/#if-elif-else-statement", 
            "text": "Now  if  you want to check for a condition after your  if  is  false , that is easy as well.\nThis is done through the  elif  statement.  i = 5\nif i   5:\n    print  i is greater than 5. \nelif i == 5:\n    print  i is equal to 5. \nelif i   5:\n    print  i is less than 5. \n\n// Output: i is equal to 5.  You can have one  if , any number of  elif  s, and an optional  else .", 
            "title": "If-Elif-Else Statement"
        }, 
        {
            "location": "/Primer/Conditionals/#unless-statement", 
            "text": "The  unless  statement is handy if you want a readable way of checking if a condition is  not  true.  i = 5\nunless i == 5:\n    print  i is not equal to 5. \n\n// Output:   It didn't output because i was equal to 5 in that case.", 
            "title": "Unless Statement"
        }, 
        {
            "location": "/Primer/Conditionals/#statement-with-modifier", 
            "text": "Like in Ruby and Perl, you can follow a statement with a modifier.  i = 0\nprint i\ni = 5 if true\nprint i\ni = 10 unless true\nprint i\n\n// Output: 0\n//         5\n//         5   Hint  Don't use Statement with Modifier on a long line. In that case, you should just create a code block.\nA good rule of thumb is to not use it if the statement is more than 3 words long. This will keep your\ncode readable and beautiful.   Some common conditionals:     Operator    Meaning    Example       ==     equal     5 == 5        !=     not equal     0 != 5            greater than     4   2            less than     2   4        =     greater than or equal to     7  = 7 and 7  = 4        =     less than or equal to     4  = 8 and 6  = 6", 
            "title": "Statement with Modifier"
        }, 
        {
            "location": "/Primer/Conditionals/#not-condition", 
            "text": "To check if a condition is not true, you would use  not .  i = 0\nif not i   5:\n    print  i is not greater than 5 \n\n// Output: i is not greater than 5", 
            "title": "Not Condition"
        }, 
        {
            "location": "/Primer/Conditionals/#combining-conditions", 
            "text": "To check more than one condition, you would use  and  or  or . Use parentheses ( ) to change the order of operations.  i = 5\nif i   0 and i   10:\n    print  i is between 0 and 10. \nif i   3 or i   7:\n    print  i is not between 3 and 7. \nif (i   0 and i   3) or (i   7 and i   10):\n    print  i is either between 0 and 3 or between 7 and 10. \n\n// Output: i is between 0 and 10.  Note that  and  requires that both comparisons are true, while  or  requires that only one is true or both are true.", 
            "title": "Combining Conditions"
        }, 
        {
            "location": "/Primer/Conditionals/#exercises", 
            "text": "Given the numbers x = 4, y = 8, and z = 6, compare them and print the middle one.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Loops/", 
            "text": "For Loop\n\n\n\n\nNote\n\n\nFor loop\n - A loop whose body gets obeyed once for each item in a sequence.\n\n\n\n\nA \nfor\n loop in Boo is not like the \nfor\n loop in languages like C and C#. It is more similar to a \nforeach\n.\n\n\nThe most common usage for a \nfor\n loop is in conjunction with the \nrange\n function.\n\n\nThe \nrange\n function creates an enumerator which yields numbers.\n\n\nThe \njoin\n function in this case, will create a string from an enumerator.\n\n\njoin and range example\n:\n\n\njoin(range(5))         // Output: 0 1 2 3 4\njoin(range(3, 7))      // Output: 3 4 5 6\njoin(range(0, 10, 2))  // Output: 0 2 4 6 8\n\n\n\n\nrange\n can be called 3 ways:\n\n\n\n\nrange(end)\n\n\nrange(start, end)\n\n\nrange(start, end, step)\n\n\n\n\nTo be used in a \nfor\n loop is quite easy.\n\n\nfor i in range(5):\n    print i\n\n// Output: 0\n//         1\n//         2\n//         3\n//         4\n\n\n\n\n\n\nNote\n\n\nPractically as fast as C#'s\n - The \nrange\n function does not create an array holding all the values called, instead it is an \nIEnumerator\n, that will quickly generate the numbers you need.\n\n\n\n\nWhile Loop\n\n\n\n\nNote\n\n\nWhile loop\n - A structure in a computer program that allows a sequence of instructions to be repeated while some condition remains true.\n\n\n\n\nThe \nwhile\n loop is very similar to an \nif\n statement, except that it will repeat itself as long as its condition is true.\n\n\ni = 0\nwhile i \n 5:\n    print i\n    i += 1\n\n// Output: 0\n//         1\n//         2\n//         3\n//         4\n\n\n\n\nIn case you didn't guess, \ni += 1\n adds 1 to \ni\n.\n\n\nContinue Keyword\n\n\n\n\nNote\n\n\nContinue keyword\n - A keyword used to resume program execution at the end of the current loop.\n\n\n\n\nThe \ncontinue\n keyword is used when looping. It will cause the position of the code to return to the start of the loop (as long as the condition still holds).\n\n\nfor i in range(10):\n    continue if i % 2 == 0\n    print i\n\n// Output: 1\n//         3\n//         5\n//         7\n//         9\n\n\n\n\nThis skips the \nprint\n part of this loop whenever \ni\n is even, causing only the odds to be printed out.\n\n\nThe \ni % 2\n actually takes the remainder of \ni\n / 2, and checks it against 0.\n\n\nWhile-Break-Unless Loop\n\n\nthe \nwhile-break-unless\n loop is very similar to other languages \ndo-while\n statement.\n\n\ni = 10\nwhile true:\n    print i\n    i -= 1\n    break unless i \n 10 and i \n 5\n\n// Output: 10\n//         9\n//         8\n//         7\n//         6\n//         5\n\n\n\n\nNormally, this would be a simple while loop.\n\n\nThis is a good method of doing things if you want to accomplish something at least once or have the loop set itself up.\n\n\nPass Keyword\n\n\nThe \npass\n keyword is useful if you don't want to accomplish anything when defining a code block.\n\n\nwhile true:\n    pass //Wait for keyboard interrupt (ctrl-C) to close program.\n\n\n\n\nExercises\n\n\n\n\nprint out all the numbers from 10 to 1.\n\n\nprint out all the squares from 1 to 100.", 
            "title": "Loops"
        }, 
        {
            "location": "/Primer/Loops/#for-loop", 
            "text": "Note  For loop  - A loop whose body gets obeyed once for each item in a sequence.   A  for  loop in Boo is not like the  for  loop in languages like C and C#. It is more similar to a  foreach .  The most common usage for a  for  loop is in conjunction with the  range  function.  The  range  function creates an enumerator which yields numbers.  The  join  function in this case, will create a string from an enumerator.  join and range example :  join(range(5))         // Output: 0 1 2 3 4\njoin(range(3, 7))      // Output: 3 4 5 6\njoin(range(0, 10, 2))  // Output: 0 2 4 6 8  range  can be called 3 ways:   range(end)  range(start, end)  range(start, end, step)   To be used in a  for  loop is quite easy.  for i in range(5):\n    print i\n\n// Output: 0\n//         1\n//         2\n//         3\n//         4   Note  Practically as fast as C#'s  - The  range  function does not create an array holding all the values called, instead it is an  IEnumerator , that will quickly generate the numbers you need.", 
            "title": "For Loop"
        }, 
        {
            "location": "/Primer/Loops/#while-loop", 
            "text": "Note  While loop  - A structure in a computer program that allows a sequence of instructions to be repeated while some condition remains true.   The  while  loop is very similar to an  if  statement, except that it will repeat itself as long as its condition is true.  i = 0\nwhile i   5:\n    print i\n    i += 1\n\n// Output: 0\n//         1\n//         2\n//         3\n//         4  In case you didn't guess,  i += 1  adds 1 to  i .", 
            "title": "While Loop"
        }, 
        {
            "location": "/Primer/Loops/#continue-keyword", 
            "text": "Note  Continue keyword  - A keyword used to resume program execution at the end of the current loop.   The  continue  keyword is used when looping. It will cause the position of the code to return to the start of the loop (as long as the condition still holds).  for i in range(10):\n    continue if i % 2 == 0\n    print i\n\n// Output: 1\n//         3\n//         5\n//         7\n//         9  This skips the  print  part of this loop whenever  i  is even, causing only the odds to be printed out.  The  i % 2  actually takes the remainder of  i  / 2, and checks it against 0.", 
            "title": "Continue Keyword"
        }, 
        {
            "location": "/Primer/Loops/#while-break-unless-loop", 
            "text": "the  while-break-unless  loop is very similar to other languages  do-while  statement.  i = 10\nwhile true:\n    print i\n    i -= 1\n    break unless i   10 and i   5\n\n// Output: 10\n//         9\n//         8\n//         7\n//         6\n//         5  Normally, this would be a simple while loop.  This is a good method of doing things if you want to accomplish something at least once or have the loop set itself up.", 
            "title": "While-Break-Unless Loop"
        }, 
        {
            "location": "/Primer/Loops/#pass-keyword", 
            "text": "The  pass  keyword is useful if you don't want to accomplish anything when defining a code block.  while true:\n    pass //Wait for keyboard interrupt (ctrl-C) to close program.", 
            "title": "Pass Keyword"
        }, 
        {
            "location": "/Primer/Loops/#exercises", 
            "text": "print out all the numbers from 10 to 1.  print out all the squares from 1 to 100.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/", 
            "text": "Lists\n\n\n\n\nNote\n\n\nList\n - A linked list that can hold a variable amount of objects.\n\n\n\n\nLists\n are mutable, which means that the \nList\n can be changed, as well as its children.\n\n\nprint([0, 'alpha', 4.5, char('d')])\nprint List('abcdefghij')\nl = List(range(5))\nprint l\nl[2] = 5\nprint l\nl[3] = 'banana'\nprint l\nl.Add(100.1)\nprint l\nl.Remove(1)\nprint l\nfor item in l:\n    print item\n\n// Output: \n// [0, alpha, 4.5, d]\n// [a, b, c, d, e, f, g, h, i, j]\n// [0, 1, 2, 3, 4]\n// [0, 1, 5, 3, 4]\n// [0, 1, 5, 'banana', 4]\n// [0, 1, 5, 'banana', 4, 100.1]\n// [0, 5, 'banana', 4, 100.1]\n// 0\n// 5\n// 'banana'\n// 4\n// 100.1\n\n\n\n\nAs you can see, \nLists\n are very flexible, which is very handy.\n\n\nLists\n can be defined two ways:\n\n\n\n\nby using brackets []\n\n\nby creating a new \nList\n wrapping an \nIEnumerator\n, or an \narray\n.\n\n\n\n\nSlicing\n\n\nSlicing is quite simple, and can be done to \nstrings\n, \nLists\n, and \narrays\n.\n\n\nIt goes in the form \nvar[start:end]\n. both start and end are optional, and must be integers, even negative integers.\n\n\nTo just get one child, use the form \nvar[position]\n. It will return a \nchar\n for a \nstring\n, an \nobject\n for a \nList\n, or the specified type for an \narray\n.\n\n\nSlicing counts up from the number 0, so 0 would be the 1st value, 1 would be the 2nd, and so on.\n\n\nlist = List(range(10))\nprint list\nprint list[:5]    // first 5\nprint list[2:5]   // starting with 2nd, go up to but not including the 5\nprint list[5:]    // everything past the 5th\nprint list[:-2]   // everything up to the 2nd to last\nprint list[-4:-2] // starting with the 4th to last, go up to 2nd to last\nprint list[5]     // the 6th\nprint list[-8]    // the 8th from last\nprint '---'\nstr = 'abcdefghij'\nprint str\nprint str[:5]     // first 5\nprint str[2:5]    // starting with 3rd, go up to but not including the 6th\nprint str[5:]     // everything past the 6th\nprint str[:-2]    // everything before the 2nd to last\nprint str[-4:-2]  // starting with the 4th to last, to before the 2nd to last\nprint str[5]      // the 6th\nprint str[-8]     // the 8th from last\n\n// Output\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n// [0, 1, 2, 3, 4]\n// [2, 3, 4]\n// [5, 6, 7, 8, 9]\n// [0, 1, 2, 3, 4, 5, 6, 7]\n// [6, 7]\n// 5\n// 2\n// ---\n// abcdefghij\n// abcde\n// cde\n// fghij\n// abcdefgh\n// gh\n// f\n// c\n\n\n\n\nI hope you get the idea. Slicing is very powerful, as it allows you to express what you need in a minimal amount of space, while still being readable.\n\n\nArrays\n\n\n\n\nNote\n\n\nArray\n - Arrays are simple objects that hold equally-sized data elements, generally of the same data type.\n\n\n\n\nArrays\n, unlike \nLists\n, cannot change their size. They can still be sliced, just not added on to.\n\nArrays\n can be defined three ways:\n1. by using parentheses ()\n  1. If you have 0 members, it's declared: \n(,)\n\n  2. If you have 1 member, it's declared: \n(member,)\n\n  3. If you have 2 or more members, it's declared: \n(one, two)\n\n2. by creating a new \narray\n wrapping an \nIEnumerator\n, or an \nList\n.\n3. by creating a blank \narray\n with a specified size: \narray(type, size)\n\n\nprint((0, 'alpha', 4.5, char('d')))\nprint array('abcdefghij')\nl = array(range(5))\nprint l\nl[2] = 5\nprint l\nl[3] = 'banana'\n\n// Output\n// (0, alpha, 4.5, d)\n// (a, b, c, d, e, f, g, h, i, j)\n// (0, 1, 2, 3, 4)\n// (0, 1, 5, 3, 4)\n// ERROR: Cannot convert 'System.String' to 'System.Int32'.\n\n\n\n\nArrays\n, unlike \nLists\n, do not necessarily group \nobjects\n. They can group any type, in the case of \narray(range(5))\n, it made an \narray\n of \nints\n.\n\n\nList to Array Conversion\n\n\nIf you create a \nList\n of \nints\n and want to turn it into an \narray\n, you have to explicitly state that the \nList\n contains \nints\n.\n\n\nlist = []\nfor i in range(5):\n    list.Add(i)\n    print list\na = array(int, list)\nfor a_s in a:\n    print a_s\na[2] += 5\nprint a\nlist[2] += 5\nprint list[2]\n\n// Output\n// [0]\n// [0, 1]\n// [0, 1, 2]\n// [0, 1, 2, 3]\n// [0, 1, 2, 3, 4]\n// (0, 1, 2, 3, 4)\n// (0, 1, 7, 3, 4)\n// ERROR: Operator '+' cannot be used with a left-hand side of type 'System.Object' and a right-hand side of type 'System.Int32'\n\n\n\n\nThis didn't work, because the List still gives out \nobjects\n instead of \nints\n, even though it only holds \nints\n.\n\n\nCasting\n\n\n\n\nNote\n\n\nTypecast\n - The conversion of a variable's data type to another data type to bypass some restrictions imposed on datatypes.\n\n\n\n\nTo get around a list storing only \nobjects\n, you can \ncast an object\n individually to what its type really is, then play with it like it should be.\n\n\nGranted, if you cast to something that is improper, say a \nstring\n to an \nint\n, Boo will emit an error.\nThere are two ways to cast an object as another data type.\n\n\n\n\nusing \nvar as \ntype\n\n\nusing \nvar cast \ntype\n\n\n\n\nlist = List(range(5))\nprint list\nfor item in list:\n    print ((item cast int) * 5)\nprint '---'\nfor item as int in list:\n    print item * item\n\n// Output\n// [0, 1, 2, 3, 4]\n// 0\n// 5\n// 10\n// 15\n// 20\n// ---\n// 0\n// 1\n// 4\n// 9\n// 16\n\n\n\n\n\n\nHint\n\n\nTry not to cast too much.  If you are constantly cast-ing, think if there is a better way to write the code.\n\n\n\n\n\n\nNote\n\n\nFeature: Generics\n - Generics, which has been part of the .NET Framework since 2.0, will allow you to create a List with a specified data type as its base.  So there is a way to not have to cast a List's items every time.\n\n\n\n\nHashes\n\n\n\n\nNote\n\n\nHash\n - A \nList\n in which the indices may be \nobjects\n, not just sequential integers in a fixed range.\n\n\n\n\nHashes\n are also called \"dictionaries\" in some other languages.\n\nHashes\n are very similar to \nLists\n, except that the key in which to set values can be an \nobject\n, though usually an \nint\n or a \nstring\n.\n\n\nHashes\n can be defined two common ways:\n\n\n\n\nby using braces {}\n\n\nby creating a new \nHash\n wrapping an \nIEnumerator\n, or an \nIDictionary\n.\n\n\n\n\nhash = {'a': 1, 'b': 2, 'monkey': 3, 42: 'the answer'}\nprint hash['a']\nprint hash[42]\nprint '---'\nfor item in hash:\n    print item.Key, '=\n', item.Value\n\n# the same hash can be created from a list like this :\nll = [ ('a',1), ('b',2), ('monkey',3), (42, \nthe answer\n) ]\nhash = Hash(ll)\n\n// Output\n// 1\n// the answer\n// ---\n// a =\n 1\n// b =\n 2\n// monkey =\n 3\n// 42 =\n the answer\n\n\n\n\nExercises\n\n\n\n\nProduce a List containing the fibonacci sequence that has 1000 values in it. (See if you can do it in 4 lines)", 
            "title": "Containers and Casting"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#lists", 
            "text": "Note  List  - A linked list that can hold a variable amount of objects.   Lists  are mutable, which means that the  List  can be changed, as well as its children.  print([0, 'alpha', 4.5, char('d')])\nprint List('abcdefghij')\nl = List(range(5))\nprint l\nl[2] = 5\nprint l\nl[3] = 'banana'\nprint l\nl.Add(100.1)\nprint l\nl.Remove(1)\nprint l\nfor item in l:\n    print item\n\n// Output: \n// [0, alpha, 4.5, d]\n// [a, b, c, d, e, f, g, h, i, j]\n// [0, 1, 2, 3, 4]\n// [0, 1, 5, 3, 4]\n// [0, 1, 5, 'banana', 4]\n// [0, 1, 5, 'banana', 4, 100.1]\n// [0, 5, 'banana', 4, 100.1]\n// 0\n// 5\n// 'banana'\n// 4\n// 100.1  As you can see,  Lists  are very flexible, which is very handy.  Lists  can be defined two ways:   by using brackets []  by creating a new  List  wrapping an  IEnumerator , or an  array .", 
            "title": "Lists"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#slicing", 
            "text": "Slicing is quite simple, and can be done to  strings ,  Lists , and  arrays .  It goes in the form  var[start:end] . both start and end are optional, and must be integers, even negative integers.  To just get one child, use the form  var[position] . It will return a  char  for a  string , an  object  for a  List , or the specified type for an  array .  Slicing counts up from the number 0, so 0 would be the 1st value, 1 would be the 2nd, and so on.  list = List(range(10))\nprint list\nprint list[:5]    // first 5\nprint list[2:5]   // starting with 2nd, go up to but not including the 5\nprint list[5:]    // everything past the 5th\nprint list[:-2]   // everything up to the 2nd to last\nprint list[-4:-2] // starting with the 4th to last, go up to 2nd to last\nprint list[5]     // the 6th\nprint list[-8]    // the 8th from last\nprint '---'\nstr = 'abcdefghij'\nprint str\nprint str[:5]     // first 5\nprint str[2:5]    // starting with 3rd, go up to but not including the 6th\nprint str[5:]     // everything past the 6th\nprint str[:-2]    // everything before the 2nd to last\nprint str[-4:-2]  // starting with the 4th to last, to before the 2nd to last\nprint str[5]      // the 6th\nprint str[-8]     // the 8th from last\n\n// Output\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n// [0, 1, 2, 3, 4]\n// [2, 3, 4]\n// [5, 6, 7, 8, 9]\n// [0, 1, 2, 3, 4, 5, 6, 7]\n// [6, 7]\n// 5\n// 2\n// ---\n// abcdefghij\n// abcde\n// cde\n// fghij\n// abcdefgh\n// gh\n// f\n// c  I hope you get the idea. Slicing is very powerful, as it allows you to express what you need in a minimal amount of space, while still being readable.", 
            "title": "Slicing"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#arrays", 
            "text": "Note  Array  - Arrays are simple objects that hold equally-sized data elements, generally of the same data type.   Arrays , unlike  Lists , cannot change their size. They can still be sliced, just not added on to. Arrays  can be defined three ways:\n1. by using parentheses ()\n  1. If you have 0 members, it's declared:  (,) \n  2. If you have 1 member, it's declared:  (member,) \n  3. If you have 2 or more members, it's declared:  (one, two) \n2. by creating a new  array  wrapping an  IEnumerator , or an  List .\n3. by creating a blank  array  with a specified size:  array(type, size)  print((0, 'alpha', 4.5, char('d')))\nprint array('abcdefghij')\nl = array(range(5))\nprint l\nl[2] = 5\nprint l\nl[3] = 'banana'\n\n// Output\n// (0, alpha, 4.5, d)\n// (a, b, c, d, e, f, g, h, i, j)\n// (0, 1, 2, 3, 4)\n// (0, 1, 5, 3, 4)\n// ERROR: Cannot convert 'System.String' to 'System.Int32'.  Arrays , unlike  Lists , do not necessarily group  objects . They can group any type, in the case of  array(range(5)) , it made an  array  of  ints .", 
            "title": "Arrays"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#list-to-array-conversion", 
            "text": "If you create a  List  of  ints  and want to turn it into an  array , you have to explicitly state that the  List  contains  ints .  list = []\nfor i in range(5):\n    list.Add(i)\n    print list\na = array(int, list)\nfor a_s in a:\n    print a_s\na[2] += 5\nprint a\nlist[2] += 5\nprint list[2]\n\n// Output\n// [0]\n// [0, 1]\n// [0, 1, 2]\n// [0, 1, 2, 3]\n// [0, 1, 2, 3, 4]\n// (0, 1, 2, 3, 4)\n// (0, 1, 7, 3, 4)\n// ERROR: Operator '+' cannot be used with a left-hand side of type 'System.Object' and a right-hand side of type 'System.Int32'  This didn't work, because the List still gives out  objects  instead of  ints , even though it only holds  ints .", 
            "title": "List to Array Conversion"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#casting", 
            "text": "Note  Typecast  - The conversion of a variable's data type to another data type to bypass some restrictions imposed on datatypes.   To get around a list storing only  objects , you can  cast an object  individually to what its type really is, then play with it like it should be.  Granted, if you cast to something that is improper, say a  string  to an  int , Boo will emit an error.\nThere are two ways to cast an object as another data type.   using  var as  type  using  var cast  type   list = List(range(5))\nprint list\nfor item in list:\n    print ((item cast int) * 5)\nprint '---'\nfor item as int in list:\n    print item * item\n\n// Output\n// [0, 1, 2, 3, 4]\n// 0\n// 5\n// 10\n// 15\n// 20\n// ---\n// 0\n// 1\n// 4\n// 9\n// 16   Hint  Try not to cast too much.  If you are constantly cast-ing, think if there is a better way to write the code.    Note  Feature: Generics  - Generics, which has been part of the .NET Framework since 2.0, will allow you to create a List with a specified data type as its base.  So there is a way to not have to cast a List's items every time.", 
            "title": "Casting"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#hashes", 
            "text": "Note  Hash  - A  List  in which the indices may be  objects , not just sequential integers in a fixed range.   Hashes  are also called \"dictionaries\" in some other languages. Hashes  are very similar to  Lists , except that the key in which to set values can be an  object , though usually an  int  or a  string .  Hashes  can be defined two common ways:   by using braces {}  by creating a new  Hash  wrapping an  IEnumerator , or an  IDictionary .   hash = {'a': 1, 'b': 2, 'monkey': 3, 42: 'the answer'}\nprint hash['a']\nprint hash[42]\nprint '---'\nfor item in hash:\n    print item.Key, '= ', item.Value\n\n# the same hash can be created from a list like this :\nll = [ ('a',1), ('b',2), ('monkey',3), (42,  the answer ) ]\nhash = Hash(ll)\n\n// Output\n// 1\n// the answer\n// ---\n// a =  1\n// b =  2\n// monkey =  3\n// 42 =  the answer", 
            "title": "Hashes"
        }, 
        {
            "location": "/Primer/Containers-and-Casting/#exercises", 
            "text": "Produce a List containing the fibonacci sequence that has 1000 values in it. (See if you can do it in 4 lines)", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Operators/", 
            "text": "Mathematical\n\n\n\n\n\n\n Name \n\n\n Syntax example \n\n\n Comments \n\n\n\n\n\n\n Multiplication \n\n\n \na * b\n \n\n\n\n\n\n\n Division \n\n\n \na / b\n \n\n\n\n\n\n\n Remainder \n\n\n \na % b\n \n\n\n Often called mod or modulus \n\n\n\n\n\n\n Addition \n\n\n \na + b\n \n\n\n\n\n\n\n Subtraction \n\n\n \na - b\n \n\n\n\n\n\n\n Exponent \n\n\n \na ** b\n \n\n\n Do not confuse this with Bitwise Xor ^ \n\n\n\n\n\n\n Bitshift Right \n\n\n \na \n b\n \n\n\n\n\n\n\n Bitshift Left \n\n\n \na \n b\n \n\n\n\n\n\n\n Bitwise And \n\n\n \na \n b\n \n\n\n\n\n\n\n Bitwise Or \n\n\n \na | b\n \n\n\n\n\n\n\n Bitwise Xor \n\n\n \na ^ b\n \n\n\n\n\n\n\n\nThe mathematical operators can also be used in the syntax \na \noperator\n= b\n, for example, \na += b\n.\n\n\nThis is merely a shortcut for \na = a \noperator\n b\n, or in our example \na = a + b\n.\n\n\nRelational and Logical\n\n\n\n\n\n\n Name \n\n\n Syntax Example \n\n\n Comments \n\n\n\n\n\n\n Less Than \n\n\n \na \n b\n \n\n\n\n\n\n\n Greater Than \n\n\n \na \n b\n \n\n\n\n\n\n\n Less Than or Equal To \n\n\n \na \n= b\n \n\n\n\n\n\n\n Greater Than or Equal To \n\n\n \na \n= b\n \n\n\n\n\n\n\n Equality \n\n\n \na == b\n \n\n\n\n\n\n\n Inequality \n\n\n \na != b\n \n\n\n\n\n\n\n Logical And \n\n\n \na and b\n \n\n\n Only use when \na\n and \nb\n are boolean values \n\n\n\n\n\n\n Logical Or \n\n\n \na or b\n \n\n\n Only use when \na\n and \nb\n are boolean values \n\n\n\n\n\n\n Logical Not \n\n\n \nnot a\n \n\n\n Only use when \na\n is a boolean value \n\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n Name \n\n\n Syntax Example \n\n\n Comments \n\n\n\n\n\n\n Typecast \n\n\n \na cast string\n \n\n\n\n\n\n\n Typecast \n\n\n \na as string\n \n\n\n\n\n\n\n Type Equality/Compatibility \n\n\n \na isa string\n \n\n\n\n\n\n\n Type Retrieval \n\n\n \ntypeof(string)\n \n\n\n\n\n\n\n Type Retrieval \n\n\n \na.GetType()\n \n\n\n\n\n\n\n\nPrimary\n\n\n\n\n\n\n Name \n\n\n Syntax Example \n\n\n Comments \n\n\n\n\n\n\n Member \n\n\n \nA.B\n \n\n\n Classes are described in \n\nPart 08 - Classes \n \n \n\n\n\n\n\n\n Function Call \n\n\n \nf(x)\n \n\n\n Functions are described in \n\nPart 07 - Functions\n\n \n\n\n\n\n\n\n Post Increment \n\n\n \ni++\n \n\n\n See \n\nDifference between Pre and Post Increment/Decrement\n\n \n\n\n\n\n\n\n Post Decrement \n\n\n \ni--\n \n\n\n See \nDifference between Pre and Post Increment/Decrement\n \n\n\n\n\n\n\n Constructor Call \n\n\n \no = MyClass()\n \n\n\n Classes are described in \nPart 08 - Classes \n \n\n\n\n\n\n\n\nUnary\n\n\n\n\n\n\n Name \n\n\n Syntax Example \n\n\n Comments \n\n\n\n\n\n\n Negative Value \n\n\n \n-5\n \n\n\n\n\n\n\n Pre Increment \n\n\n \n++i\n \n\n\n See [Difference between Pre and Post Increment/Decrement](https://github.com/bamboo/boo/wiki/Boo-Primer:-%5BPart-06%5D-Operators)\n \n\n\n\n\n\n\n Pre Decrement \n\n\n \n--i\n \n\n\n See [Difference between Pre and Post Increment/Decrement](https://github.com/bamboo/boo/wiki/Boo-Primer:-%5BPart-06%5D-Operators)\n \n\n\n\n\n\n\n Grouping \n\n\n \n(a + b)\n \n\n\n\n\n\n\n\nDifference between Pre and Post Increment/Decrement\n\n\nWhen writing inline code, Pre Increment/Decrement (+i/-i) commit the action, then return its new value, whereas Post Increment/Decrement (i+/i-) return the current value, then commit the change.\n\n\npreincrement vs. postincrement\n\n\nnum = 0\nfor i in range(5):\n    print num++\nprint '---'\nnum = 0\nfor i in range(5):\n    print ++num\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// ---\n// 1\n// 2\n// 3\n// 4\n// 5\n\n\n\n\n\n\nHint\n\n\nTo make your code more readable, avoid using the incrementors and decrementors. Instead, use i += 1 and i -= 1.\n\n\n\n\nExercises\n\n\n\n\nPut your hands on a wall, move your left foot back about 3 feet, move the right foot back 2 feet.", 
            "title": "Operators"
        }, 
        {
            "location": "/Primer/Operators/#mathematical", 
            "text": "Name    Syntax example    Comments      Multiplication     a * b       Division     a / b       Remainder     a % b     Often called mod or modulus      Addition     a + b       Subtraction     a - b       Exponent     a ** b     Do not confuse this with Bitwise Xor ^      Bitshift Right     a   b       Bitshift Left     a   b       Bitwise And     a   b       Bitwise Or     a | b       Bitwise Xor     a ^ b      The mathematical operators can also be used in the syntax  a  operator = b , for example,  a += b .  This is merely a shortcut for  a = a  operator  b , or in our example  a = a + b .", 
            "title": "Mathematical"
        }, 
        {
            "location": "/Primer/Operators/#relational-and-logical", 
            "text": "Name    Syntax Example    Comments      Less Than     a   b       Greater Than     a   b       Less Than or Equal To     a  = b       Greater Than or Equal To     a  = b       Equality     a == b       Inequality     a != b       Logical And     a and b     Only use when  a  and  b  are boolean values      Logical Or     a or b     Only use when  a  and  b  are boolean values      Logical Not     not a     Only use when  a  is a boolean value", 
            "title": "Relational and Logical"
        }, 
        {
            "location": "/Primer/Operators/#types", 
            "text": "Name    Syntax Example    Comments      Typecast     a cast string       Typecast     a as string       Type Equality/Compatibility     a isa string       Type Retrieval     typeof(string)       Type Retrieval     a.GetType()", 
            "title": "Types"
        }, 
        {
            "location": "/Primer/Operators/#primary", 
            "text": "Name    Syntax Example    Comments      Member     A.B     Classes are described in  Part 08 - Classes \n        Function Call     f(x)     Functions are described in  Part 07 - Functions       Post Increment     i++     See  Difference between Pre and Post Increment/Decrement       Post Decrement     i--     See  Difference between Pre and Post Increment/Decrement       Constructor Call     o = MyClass()     Classes are described in  Part 08 - Classes", 
            "title": "Primary"
        }, 
        {
            "location": "/Primer/Operators/#unary", 
            "text": "Name    Syntax Example    Comments      Negative Value     -5       Pre Increment     ++i     See [Difference between Pre and Post Increment/Decrement](https://github.com/bamboo/boo/wiki/Boo-Primer:-%5BPart-06%5D-Operators)       Pre Decrement     --i     See [Difference between Pre and Post Increment/Decrement](https://github.com/bamboo/boo/wiki/Boo-Primer:-%5BPart-06%5D-Operators)       Grouping     (a + b)", 
            "title": "Unary"
        }, 
        {
            "location": "/Primer/Operators/#difference-between-pre-and-post-incrementdecrement", 
            "text": "When writing inline code, Pre Increment/Decrement (+i/-i) commit the action, then return its new value, whereas Post Increment/Decrement (i+/i-) return the current value, then commit the change.  preincrement vs. postincrement  num = 0\nfor i in range(5):\n    print num++\nprint '---'\nnum = 0\nfor i in range(5):\n    print ++num\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// ---\n// 1\n// 2\n// 3\n// 4\n// 5   Hint  To make your code more readable, avoid using the incrementors and decrementors. Instead, use i += 1 and i -= 1.", 
            "title": "Difference between Pre and Post Increment/Decrement"
        }, 
        {
            "location": "/Primer/Operators/#exercises", 
            "text": "Put your hands on a wall, move your left foot back about 3 feet, move the right foot back 2 feet.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Functions/", 
            "text": "Note\n\n\nFunction\n - A sequence of code which performs a specific task, as part of a larger program, and is grouped as one, or more, statement blocks.\n\n\n\n\nBuiltin Functions\n\n\nYou have already seen a few functions. \nrange()\n, \nprint()\n, and \njoin()\n.\n\n\nThese are functions built into Boo.\n\n\nHere's a list of all the builtin functions that Boo offers:\n\n\n\n\n\n\n Name \n\n\n Description \n\n\n Syntax example \n\n\n\n\n\n\n \nprint\n \n\n\n Prints an \nobject\n to Standard Out. The equivilent of \nSystem.Console.WriteLine\n \n\n\n \nprint(\"hey\")\n \n\n\n\n\n\n\n \ngets\n \n\n\n Returns a \nstring\n of input that originates from \nSystem.Console.ReadLine()\n - Standard Input \n\n\n \ninput = gets()\n \n\n\n\n\n\n\n \nprompt\n \n\n\n Prompts the user for information. \n\n\n \ninput = prompt(\"How are you? \")\n \n\n\n\n\n\n\n \njoin\n \n\n\n Walk through an \nIEnumerable\n \nobject\n and put all of those elements into one string. \n\n\n \njoin([1, 2, 3, 4, 5]) == \"1 2 3 4 5\"\n \n\n\n\n\n\n\n \nmap\n \n\n\n Returns an \nIEnumerable\n \nobject\n that applies a specific function to each element in another \nIEnumerable\n \nobject\n. \n\n\n \nmap([1, 2, 3, 4, 5], func)\n \n\n\n\n\n\n\n \narray\n \n\n\n Used to create an empty \narray\n or convert \nIEnumerable\n and \nICollection objects\n to an \narray\n \n\n\n \narray(int, [1, 2, 3, 4, 5]) == (1, 2, 3, 4, 5)\n \n\n\n\n\n\n\n \nmatrix\n \n\n\n Creates a multidimensional \narray\n. See \n\n\nMultidimensional Arrays for more info. \n\n\n \nmatrix(int, 2, 2)\n \n\n\n\n\n\n\n \niterator\n \n\n\n Creates an \nIEnumerable\n from an \nobject\n \n\n\n \nList(iterator('abcde')) == ['a', 'b', 'c', 'd', 'e']\n \n\n\n\n\n\n\n \nshellp\n \n\n\n Start a \nProcess\n. Returns a \nProcess\n \nobject\n \n\n\n \nprocess = shellp(\"MyProgram.exe\", \"\")\n \n\n\n\n\n\n\n \nshell\n \n\n\n Invoke an application. Returns a \nstring\n containing the program's output to Standard Out \n\n\n \ninput = shell(\"echo hi there\", \"\")\n \n\n\n\n\n\n\n \nshellm\n \n\n\n Execute the specified managed application in a new \nAppDomain\n. Returns a \nstring\n containing the program's output to Standard Out \n\n\n \ninput = shellm(\"MyProgram.exe\", (,))\n \n\n\n\n\n\n\n \nenumerate\n \n\n\n Creates an \nIEnumerator\n from another, but gives it a pairing of \n(\nindex\n,\n \nvalue\n)\n \n\n\n \nList(enumerate(range(5, 8))) == [(0, 5), (1, 6), (2, 7)]\n \n\n\n\n\n\n\n \nrange\n \n\n\n Returns an \nIEnumerable\n containing a list of \nints\n \n\n\n \nList(range(5)) == [0, 1, 2, 3, 4]\n \n\n\n\n\n\n\n \nreversed\n \n\n\n Returns an \nIEnumerable\n with its members in reverse order \n\n\n \nList(reversed(range(5))) == [4, 3, 2, 1, 0]\n \n\n\n\n\n\n\n \nzip\n \n\n\n Returns an \nIEnumerable\n that is a \"mesh\" of two or more \nIEnumerables\n. \n\n\n \narray(zip([1, 2, 3], [4, 5, 6])) == [(1, 4), (2, 5), (3, 6)]\n \n\n\n\n\n\n\n \ncat\n \n\n\n Concatenate two or more \nIEnumerators\n head-to-tail \n\n\n \nList(cat(range(3), range(3, 6))) == [0, 1, 2, 3, 4, 5]\n \n\n\n\n\n\n\n\nThese are all very handy to know. Not required, but it makes programming all that much easier.\n\n\nDefining Your Own Functions\n\n\nIt's very simple to define your own functions as well.\n\n\ndef Hello():\n    return \nHello, World!\n\n\nprint Hello()\n\n// Output: Hello, World!\n\n\n\n\nNow it's ok if you don't understand any of that, I'll go through it step-by-step.\n\n\n\n\ndef Hello():\n\n\ndef\n declares that you are starting to declare a function. \ndef\n is short for \"define\".\n\n\nHello\n is the name of the function. You could call it almost anything you wanted, as long as it doesn't have any spaces and doesn't start with a number.\n\n\n()\n this means what kind of arguments the function will take. Since we don't accept any arguments, it is left blank.\n\n\nreturn \"Hello, World!\"\n\n\nreturn\n is a keyword that lets the function know what to emit to its invoker.\n\n\n\"Hello, World!\"\n is the string that the \nreturn\n statement will send.\n\n\nprint Hello()\n\n\nprint\n is the happy little \nprint\n macro that we covered before.\n\n\nHello()\n calls the \nHello\n function with no \n()\n arguments.\n\n\n\n\nLike variables, function types are inferred.\n\n\ndef Hello():\n    return \nHello, World!\n\n\n\n\n\nwill always return a string, so Boo will infer that string is its return type. You could have done this to achieve the same result:\n\n\ndef Hello() as string:\n    return \nHello, World!\n\n\n\n\n\n\n\nHint\n\n\nIf it is not obvious, specify the return type for a function.\n\n\n\n\nIf Boo cannot infer a return type, it will assume \nobject\n. If there is no return type then the return type is called 'void', which basically means nothing. To have no return type you can leave off the \nreturn\n, or have a \nreturn\n with no expression. If there are multiple return}}s with different {{return types, it will return the closest common ancestor, often times \nobject\n but not always.\n\n\nArguments\n\n\n\n\nNote\n\n\nArgument\n - A way of allowing the same sequence of commands to operate on different data without re-specifying the instructions.\n\n\n\n\nArguments are very handy, as they can allow a function to do different things based on the input.\n\n\ndef Hello(name as string):\n    return \nHello, ${name}!\n\n\nprint Hello(\nMonkey\n)\n\n// Output: Hello, Monkey!\n\n\n\n\nHere it is again, step-by-step.\n\n\n\n\ndef Hello(name as string):\n\n\ndef\n declares that you are starting to declare a function.\n\n\nHello\n is the name of the function. You could call it almost anything you wanted, as long as it doesn't have any spaces and doesn't start with a number.\n\n\n(name as string)\n this means what kind of arguments the function will take. This function will take one argument: \nname\n. When you call the function, the \nname\n must be a string, otherwise you will get a compiler error - \"The best overload for the method Hello is not compatible with the argument list '(The,Types, of, The, Parameters, Entered)'.\"\n\n\nreturn \"Hello, ${name}!\"\n\n\nreturn\n is a keyword that exits the function, and optionally return a value to the caller.\n\n\n\"Hello, ${name}!\"\n uses \nString Interpolation\n to place the value of name directly into the string.\n\n\nprint Hello(\"Monkey\")\n\n\nprint\n is the happy little print macro that we covered \nbefore\n.\n\n\nHello(\"Monkey\")\n calls the Hello function with the (\"Monkey\") argument.\n\n\n\n\nFunction Overloading\n\n\n\n\nNote\n\n\nOverloading\n - Giving multiple meanings to the same name, but making them distinguishable by context. For example, two procedures with the same name are overloading that name as long as the compiler can determine which one you mean from contextual information such as the type and number of parameters that you supply when you call it.\n\n\n\n\nFunction overloading takes place when a function is declared multiple times with different arguments.\n\n\ndef Hello():\n    return \nHello, World!\n\n\ndef Hello(name as string):\n    return \nHello, ${name}!\n\n\ndef Hello(num as int):\n    return \nHello, Number ${num}!\n\n\ndef Hello(name as string, other as string):\n    return \nHello, ${name} and ${other}!\n\n\nprint Hello()\nprint Hello(\nMonkey\n)\nprint Hello(2)\nprint Hello(\nCat\n, \nDog\n)\n\n// Output: \n// Hello, World!\n// Hello, Monkey!\n// Hello, Number 2!\n// Hello, Cat and Dog!\n\n\n\n\nVariable Arguments\n\n\nThere is a way to pass an arbitrary number of arguments.\n\n\ndef Test(*args as (object)):\n    return args.Length\n\nprint Test(\nhey\n, \nthere\n)\nprint Test(1, 2, 3, 4, 5)\nprint Test(\ntest\n)\n\na = (5, 8, 1)\nprint Test(*a)\n\n// Output: \n// 2\n// 5\n// 1\n// 3\n\n\n\n\nThe star * lets it known that everything past that is arbitrary.\n\n\nIt is also used to explode parameters, as in \nprint Test(*a)\n causes 3 arguments to be passed.\n\n\nYou can have required parameters before the *args, just like in any other function, but not after, as after all the required parameters are supplied the rest are past into your argument array.\n\n\nExercises\n\n\n\n\nWrite a function that prints something nice if it is fed an even number and prints something mean if it is fed an odd number.", 
            "title": "Functions"
        }, 
        {
            "location": "/Primer/Functions/#builtin-functions", 
            "text": "You have already seen a few functions.  range() ,  print() , and  join() .  These are functions built into Boo.  Here's a list of all the builtin functions that Boo offers:     Name    Description    Syntax example       print     Prints an  object  to Standard Out. The equivilent of  System.Console.WriteLine      print(\"hey\")        gets     Returns a  string  of input that originates from  System.Console.ReadLine()  - Standard Input     input = gets()        prompt     Prompts the user for information.     input = prompt(\"How are you? \")        join     Walk through an  IEnumerable   object  and put all of those elements into one string.     join([1, 2, 3, 4, 5]) == \"1 2 3 4 5\"        map     Returns an  IEnumerable   object  that applies a specific function to each element in another  IEnumerable   object .     map([1, 2, 3, 4, 5], func)        array     Used to create an empty  array  or convert  IEnumerable  and  ICollection objects  to an  array      array(int, [1, 2, 3, 4, 5]) == (1, 2, 3, 4, 5)        matrix     Creates a multidimensional  array . See  \nMultidimensional Arrays for more info.     matrix(int, 2, 2)        iterator     Creates an  IEnumerable  from an  object      List(iterator('abcde')) == ['a', 'b', 'c', 'd', 'e']        shellp     Start a  Process . Returns a  Process   object      process = shellp(\"MyProgram.exe\", \"\")        shell     Invoke an application. Returns a  string  containing the program's output to Standard Out     input = shell(\"echo hi there\", \"\")        shellm     Execute the specified managed application in a new  AppDomain . Returns a  string  containing the program's output to Standard Out     input = shellm(\"MyProgram.exe\", (,))        enumerate     Creates an  IEnumerator  from another, but gives it a pairing of  ( index ,   value )      List(enumerate(range(5, 8))) == [(0, 5), (1, 6), (2, 7)]        range     Returns an  IEnumerable  containing a list of  ints      List(range(5)) == [0, 1, 2, 3, 4]        reversed     Returns an  IEnumerable  with its members in reverse order     List(reversed(range(5))) == [4, 3, 2, 1, 0]        zip     Returns an  IEnumerable  that is a \"mesh\" of two or more  IEnumerables .     array(zip([1, 2, 3], [4, 5, 6])) == [(1, 4), (2, 5), (3, 6)]        cat     Concatenate two or more  IEnumerators  head-to-tail     List(cat(range(3), range(3, 6))) == [0, 1, 2, 3, 4, 5]      These are all very handy to know. Not required, but it makes programming all that much easier.", 
            "title": "Builtin Functions"
        }, 
        {
            "location": "/Primer/Functions/#defining-your-own-functions", 
            "text": "It's very simple to define your own functions as well.  def Hello():\n    return  Hello, World! \n\nprint Hello()\n\n// Output: Hello, World!  Now it's ok if you don't understand any of that, I'll go through it step-by-step.   def Hello():  def  declares that you are starting to declare a function.  def  is short for \"define\".  Hello  is the name of the function. You could call it almost anything you wanted, as long as it doesn't have any spaces and doesn't start with a number.  ()  this means what kind of arguments the function will take. Since we don't accept any arguments, it is left blank.  return \"Hello, World!\"  return  is a keyword that lets the function know what to emit to its invoker.  \"Hello, World!\"  is the string that the  return  statement will send.  print Hello()  print  is the happy little  print  macro that we covered before.  Hello()  calls the  Hello  function with no  ()  arguments.   Like variables, function types are inferred.  def Hello():\n    return  Hello, World!   will always return a string, so Boo will infer that string is its return type. You could have done this to achieve the same result:  def Hello() as string:\n    return  Hello, World!    Hint  If it is not obvious, specify the return type for a function.   If Boo cannot infer a return type, it will assume  object . If there is no return type then the return type is called 'void', which basically means nothing. To have no return type you can leave off the  return , or have a  return  with no expression. If there are multiple return}}s with different {{return types, it will return the closest common ancestor, often times  object  but not always.", 
            "title": "Defining Your Own Functions"
        }, 
        {
            "location": "/Primer/Functions/#arguments", 
            "text": "Note  Argument  - A way of allowing the same sequence of commands to operate on different data without re-specifying the instructions.   Arguments are very handy, as they can allow a function to do different things based on the input.  def Hello(name as string):\n    return  Hello, ${name}! \n\nprint Hello( Monkey )\n\n// Output: Hello, Monkey!  Here it is again, step-by-step.   def Hello(name as string):  def  declares that you are starting to declare a function.  Hello  is the name of the function. You could call it almost anything you wanted, as long as it doesn't have any spaces and doesn't start with a number.  (name as string)  this means what kind of arguments the function will take. This function will take one argument:  name . When you call the function, the  name  must be a string, otherwise you will get a compiler error - \"The best overload for the method Hello is not compatible with the argument list '(The,Types, of, The, Parameters, Entered)'.\"  return \"Hello, ${name}!\"  return  is a keyword that exits the function, and optionally return a value to the caller.  \"Hello, ${name}!\"  uses  String Interpolation  to place the value of name directly into the string.  print Hello(\"Monkey\")  print  is the happy little print macro that we covered  before .  Hello(\"Monkey\")  calls the Hello function with the (\"Monkey\") argument.", 
            "title": "Arguments"
        }, 
        {
            "location": "/Primer/Functions/#function-overloading", 
            "text": "Note  Overloading  - Giving multiple meanings to the same name, but making them distinguishable by context. For example, two procedures with the same name are overloading that name as long as the compiler can determine which one you mean from contextual information such as the type and number of parameters that you supply when you call it.   Function overloading takes place when a function is declared multiple times with different arguments.  def Hello():\n    return  Hello, World! \n\ndef Hello(name as string):\n    return  Hello, ${name}! \n\ndef Hello(num as int):\n    return  Hello, Number ${num}! \n\ndef Hello(name as string, other as string):\n    return  Hello, ${name} and ${other}! \n\nprint Hello()\nprint Hello( Monkey )\nprint Hello(2)\nprint Hello( Cat ,  Dog )\n\n// Output: \n// Hello, World!\n// Hello, Monkey!\n// Hello, Number 2!\n// Hello, Cat and Dog!", 
            "title": "Function Overloading"
        }, 
        {
            "location": "/Primer/Functions/#variable-arguments", 
            "text": "There is a way to pass an arbitrary number of arguments.  def Test(*args as (object)):\n    return args.Length\n\nprint Test( hey ,  there )\nprint Test(1, 2, 3, 4, 5)\nprint Test( test )\n\na = (5, 8, 1)\nprint Test(*a)\n\n// Output: \n// 2\n// 5\n// 1\n// 3  The star * lets it known that everything past that is arbitrary.  It is also used to explode parameters, as in  print Test(*a)  causes 3 arguments to be passed.  You can have required parameters before the *args, just like in any other function, but not after, as after all the required parameters are supplied the rest are past into your argument array.", 
            "title": "Variable Arguments"
        }, 
        {
            "location": "/Primer/Functions/#exercises", 
            "text": "Write a function that prints something nice if it is fed an even number and prints something mean if it is fed an odd number.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Classes/", 
            "text": "Note\n\n\nClass\n - A cohesive package that consists of a particular kind of compile-time metadata. A class describes the rules by which objects behave. A class specifies the structure of data which each instance contains as well as the methods (functions) which manipulate the data of the object.\n\n\n\n\n\n\nNote\n\n\nObject\n - An instance of a class\n\n\n\n\nDefining a Class\n\n\nClasses\n are important because they allow you to split up your code into simpler, logical parts. They also allow for better organization and data manipulation.\n\n\nclass Cat:\n    pass\n\nfluffy = Cat()\n\n\n\n\nThis declares a blank \nclass\n called \"Cat\". It can't do anything at all, because there's nothing to do with it. \nfluffy\n\n\n\n\nHint\n\n\nName all your classes using PascalCase. That is, Capitalize every word and don't use spaces. If it includes an acronym, like \"URL\", call it \"Url\".\n\n\n\n\nFields and Properties\n\n\n\n\nNote\n\n\nField\n - An element in a class that contains a specific term of information.\n\n\n\n\n\n\nNote\n\n\nProperty\n - A syntax nicety to use instead of getter/setter functions.\n\n\n\n\nSimply, fields hold information and properies are accessors to that information.\n\n\nclass Cat:\n    [Property(Name)]\n    _name as string\n\nfluffy = Cat()\nfluffy.Name = \nFluffy\n\n\n\n\n\n\n\nclass Cat:\n declares the start of a class.\n\n\n[Property(Name)]\n declares a property around \n_name\n. You named the property \"Name\".\n\n\n_name as string\n declares a \nfield\n of \nCat\n that is a \nstring\n called \n_name\n.\n\n\nfluffy = Cat()\n declares an instance of \nCat\n.\n\n\nfluffy.Name = 'Fluffy'\n accesses the property \nName\n of \nCat\n and sets its value to 'Fluffy'. This will cause \nName\n to set \n_name\n to 'Fluffy'.\n\n\n\n\nFields are not set directly because of security.\n\n\n\n\nHint\n\n\nName all your properties using PascalCase, just like \nclasses\n. Name all your \nfields\n using _underscoredCamelCase, which is similar to PascalCase, only it is prefixed with an underscore and the first letter is lowercase.\n\n\n\n\nThere are two other types of \nproperties\n, a \ngetter\n and a \nsetter\n. Technically, a regular \nproperty\n is just the combination of the two.\n\n\nclass Cat:\n    [Getter(Name)]\n    _name = 'Meowster'\n\n    [Setter(FavoriteFood)]\n    _favoriteFood as string\n\nfluffy = Cat()\nprint fluffy.Name\nfluffy.FavoriteFood = 'Broccoli'\n\n// Output: Meowster\n\n\n\n\nIf you were to try to assign a value to \nfluffy.Name\n or retrieve a value from \nfluffy.FavoriteFood\n, an error would have occurred, because the code just does not exist for you to do that.\nUsing the \nattributes\n \nProperty\n, \nGetter\n, and \nSetter\n are very handy, but it's actually Boo's shortened version of what is really happening. Here's an example of the full code.\n\n\nclass Cat:\n    Name as string:\n        get:\n            return _name\n        set:\n            _name = value\n\n    _name as string\n\nfluffy = Cat()\nfluffy.Name = 'Fluffy'\n\n\n\n\nBecause \nfields\n are visible inside their own class, you can see that \nName\n is just a wrapper around _name\n. Using this expanded syntax is handy if you want to do extra verification or not have it wrap exactly around its\nfield`, maybe by trimming whitespace or something like that first.\n\n\nvalue\n is a special keyword for the setter statement, that contains the value to be assigned.\n\n\n\n\nHint\n\n\nProperty Pre-condition: It is also possible to define a precondition that must be met before setting\na value directly through the Property shorthand.\n\n\n\n\nclass Cat:\n    [Property(Name, Name is not null)]\n    _name as string\n\nfluffy = Cat()\nfluffy.Name = null # will raise an ArgumentException\n\n\n\n\nClass Modifiers\n\n\n\n\n\n\n Modifier \n\n\n Description \n\n\n\n\n\n\n \npublic\n \n\n\n Creates a normal, public class, fully accessible to all other types. \n\n\n\n\n\n\n \nprotected\n \n\n\n Creates a class that is only accessible by its containing class (the class this was declared in) and any inheriting classes. \n\n\n\n\n\n\n \ninternal\n \n\n\n A class only accessible by the assembly it was declared in. \n\n\n\n\n\n\n \nprotected internal\n \n\n\n Combination of protected and internal. \n\n\n\n\n\n\n \nprivate\n \n\n\n Creates a class that is only accessible by its containing class (the class this was declared in.) \n\n\n\n\n\n\n \nabstract\n \n\n\n Creates a class that cannot be instanced. This is designed to be a base class for others. \n\n\n\n\n\n\n \nfinal\n \n\n\n Creates a class that cannot be inherited from. \n\n\n\n\n\n\n\n\n\nHint\n\n\nNever use the public Class Modifier. It is assumed to be public if you specify no modifier.\n\n\n\n\nabstract class Cat:\n    [Property(Name)]\n    _name as string\n\n\n\n\nThe \nabstract\n keyword is the Class Modifier.\n\n\nInheritance\n\n\n\n\nNote\n\n\nInheritance\n - A way to form new classes (instances of which will be objects) using pre-defined objects or classes where new ones simply take over old ones's implemetions and characterstics. It is intended to help reuse of existing code with little or no modification.\n\n\n\n\nInheritance is very simple in Boo.\n\n\nclass Cat(Feline):\n    [Property(Name)]\n    _name as string\n\nclass Feline:\n    [Property(Weight)]\n    _weight as single //In Kilograms\n\n\n\n\nThis causes \nCat\n to inherit from \nFeline\n. This gives the members \nWeight\n and \n_weight\n to \nCat\n, even though they were not declared in \nCat\n itself.\n\n\nYou can also have more than one \nclass\n inherit from the same \nclass\n, which promotes code reuse.\n\n\nMore about inheritance is covered in \nPart 10 - Polymorphism, or Inherited Methods\n\n\nClasses\n can inherit from one or zero other \nclasses\n and any number of `interfaces.\n\n\nTo inherit from more than one interface, you would use the notation \nclass Child(IBaseOne, IBaseTwo, IBaseThree):\n\n\nInterfaces\n\n\n\n\nNote\n\n\nInterface\n - An interface defines a list of methods that enables a class to implement the interface itself.\n\n\n\n\nInterfaces\n allow you to set up an API (Application Programming Interface) for \nclasses\n to base themselves off of.\nNo implementation of code is put inside \ninterfaces\n, that is up to the \nclasses\n.\n\nInterfaces\n can inherit from any number of other \ninterfaces\n. They cannot inherit from any \nclasses\n.\n\n\ninterface IFeline:\n    def Roar()\n\n    Name:\n        get\n        set\n\n\n\n\nThis defines IFeline having one method, Roar, and one \nproperty\n, Name. \nProperties\n must be explicitly declared in \ninterfaces\n. Methods are explained in Part 09 - Methods.\n\n\n\n\nHint\n\n\nName your interfaces using PascalCase prefixed with the letter \nI\n, such as \nIFeline\n.\n\n\n\n\nDifference between Value and Reference Types\n\n\nThere are two types in the Boo/.NET world: Value and Reference types. All classes form Reference types. Numbers and such as was discussed in Part 02 - Variables#List of Value Types are value types.\n\n\n\n\nNote\n\n\nnull\n - A keyword used to specify an undefined value for reference variables.\n\n\n\n\nValue types can never be set to \nnull\n, they will always have a default value. Numbers default value will generally be 0.\n\n\nExercises\n\n\n\n\nCreate a class that inherits from more than one interface.\n\n\nSee what happens if you try to inherit from more than one class.", 
            "title": "Classes"
        }, 
        {
            "location": "/Primer/Classes/#defining-a-class", 
            "text": "Classes  are important because they allow you to split up your code into simpler, logical parts. They also allow for better organization and data manipulation.  class Cat:\n    pass\n\nfluffy = Cat()  This declares a blank  class  called \"Cat\". It can't do anything at all, because there's nothing to do with it.  fluffy   Hint  Name all your classes using PascalCase. That is, Capitalize every word and don't use spaces. If it includes an acronym, like \"URL\", call it \"Url\".", 
            "title": "Defining a Class"
        }, 
        {
            "location": "/Primer/Classes/#fields-and-properties", 
            "text": "Note  Field  - An element in a class that contains a specific term of information.    Note  Property  - A syntax nicety to use instead of getter/setter functions.   Simply, fields hold information and properies are accessors to that information.  class Cat:\n    [Property(Name)]\n    _name as string\n\nfluffy = Cat()\nfluffy.Name =  Fluffy    class Cat:  declares the start of a class.  [Property(Name)]  declares a property around  _name . You named the property \"Name\".  _name as string  declares a  field  of  Cat  that is a  string  called  _name .  fluffy = Cat()  declares an instance of  Cat .  fluffy.Name = 'Fluffy'  accesses the property  Name  of  Cat  and sets its value to 'Fluffy'. This will cause  Name  to set  _name  to 'Fluffy'.   Fields are not set directly because of security.   Hint  Name all your properties using PascalCase, just like  classes . Name all your  fields  using _underscoredCamelCase, which is similar to PascalCase, only it is prefixed with an underscore and the first letter is lowercase.   There are two other types of  properties , a  getter  and a  setter . Technically, a regular  property  is just the combination of the two.  class Cat:\n    [Getter(Name)]\n    _name = 'Meowster'\n\n    [Setter(FavoriteFood)]\n    _favoriteFood as string\n\nfluffy = Cat()\nprint fluffy.Name\nfluffy.FavoriteFood = 'Broccoli'\n\n// Output: Meowster  If you were to try to assign a value to  fluffy.Name  or retrieve a value from  fluffy.FavoriteFood , an error would have occurred, because the code just does not exist for you to do that.\nUsing the  attributes   Property ,  Getter , and  Setter  are very handy, but it's actually Boo's shortened version of what is really happening. Here's an example of the full code.  class Cat:\n    Name as string:\n        get:\n            return _name\n        set:\n            _name = value\n\n    _name as string\n\nfluffy = Cat()\nfluffy.Name = 'Fluffy'  Because  fields  are visible inside their own class, you can see that  Name  is just a wrapper around _name . Using this expanded syntax is handy if you want to do extra verification or not have it wrap exactly around its field`, maybe by trimming whitespace or something like that first.  value  is a special keyword for the setter statement, that contains the value to be assigned.   Hint  Property Pre-condition: It is also possible to define a precondition that must be met before setting\na value directly through the Property shorthand.   class Cat:\n    [Property(Name, Name is not null)]\n    _name as string\n\nfluffy = Cat()\nfluffy.Name = null # will raise an ArgumentException", 
            "title": "Fields and Properties"
        }, 
        {
            "location": "/Primer/Classes/#class-modifiers", 
            "text": "Modifier    Description       public     Creates a normal, public class, fully accessible to all other types.       protected     Creates a class that is only accessible by its containing class (the class this was declared in) and any inheriting classes.       internal     A class only accessible by the assembly it was declared in.       protected internal     Combination of protected and internal.       private     Creates a class that is only accessible by its containing class (the class this was declared in.)       abstract     Creates a class that cannot be instanced. This is designed to be a base class for others.       final     Creates a class that cannot be inherited from.      Hint  Never use the public Class Modifier. It is assumed to be public if you specify no modifier.   abstract class Cat:\n    [Property(Name)]\n    _name as string  The  abstract  keyword is the Class Modifier.", 
            "title": "Class Modifiers"
        }, 
        {
            "location": "/Primer/Classes/#inheritance", 
            "text": "Note  Inheritance  - A way to form new classes (instances of which will be objects) using pre-defined objects or classes where new ones simply take over old ones's implemetions and characterstics. It is intended to help reuse of existing code with little or no modification.   Inheritance is very simple in Boo.  class Cat(Feline):\n    [Property(Name)]\n    _name as string\n\nclass Feline:\n    [Property(Weight)]\n    _weight as single //In Kilograms  This causes  Cat  to inherit from  Feline . This gives the members  Weight  and  _weight  to  Cat , even though they were not declared in  Cat  itself.  You can also have more than one  class  inherit from the same  class , which promotes code reuse.  More about inheritance is covered in  Part 10 - Polymorphism, or Inherited Methods  Classes  can inherit from one or zero other  classes  and any number of `interfaces.  To inherit from more than one interface, you would use the notation  class Child(IBaseOne, IBaseTwo, IBaseThree):", 
            "title": "Inheritance"
        }, 
        {
            "location": "/Primer/Classes/#interfaces", 
            "text": "Note  Interface  - An interface defines a list of methods that enables a class to implement the interface itself.   Interfaces  allow you to set up an API (Application Programming Interface) for  classes  to base themselves off of.\nNo implementation of code is put inside  interfaces , that is up to the  classes . Interfaces  can inherit from any number of other  interfaces . They cannot inherit from any  classes .  interface IFeline:\n    def Roar()\n\n    Name:\n        get\n        set  This defines IFeline having one method, Roar, and one  property , Name.  Properties  must be explicitly declared in  interfaces . Methods are explained in Part 09 - Methods.   Hint  Name your interfaces using PascalCase prefixed with the letter  I , such as  IFeline .", 
            "title": "Interfaces"
        }, 
        {
            "location": "/Primer/Classes/#difference-between-value-and-reference-types", 
            "text": "There are two types in the Boo/.NET world: Value and Reference types. All classes form Reference types. Numbers and such as was discussed in Part 02 - Variables#List of Value Types are value types.   Note  null  - A keyword used to specify an undefined value for reference variables.   Value types can never be set to  null , they will always have a default value. Numbers default value will generally be 0.", 
            "title": "Difference between Value and Reference Types"
        }, 
        {
            "location": "/Primer/Classes/#exercises", 
            "text": "Create a class that inherits from more than one interface.  See what happens if you try to inherit from more than one class.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Methods/", 
            "text": "Note\n\n\nMethod\n - A function exclusively associated with a class.\n\n\n\n\nDefining a Method\n\n\nMethods must be defined in \nclasses\n. They are declared just like functions are.\n\n\nclass Cat:\n    def Roar():\n        print \nMeow!\n\n\ncat = Cat()\ncat.Roar()\n\n// Output: Meow!\n\n\n\n\nAn object of \nCat\n must be instanced, then its methods can be called.\n\n\n\n\nHint\n\n\nNames of methods should always be verbs. They should also be declared in PascalCase.\n\n\n\n\nClass Constructor and Destructor\n\n\nConstructors and Destructors are special methods that are called on when a \nclass\n is being instanced or destroyed, respectively. Both are optional.\n\n\nclass Cat:\n    def constructor():\n        _name = 'Whiskers'\n\n    def destructor():\n        print \n$_name is no more... RIP\n\n\n    [Getter(Name)]\n    _name as string\n\ncat = Cat()\nprint cat.Name\n\n// Output:\n// Whiskers\n// Whiskers is no more... RIP\n\n\n\n\nIf a constructor has arguments, then they must be supplied when instancing. Destructors cannot have arguments.\n\n\nclass Cat:\n    def constructor(name as string):\n        _name = name\n\n    [Getter(Name)]\n    _name as string\n\ncat = Cat(\nButtons\n)\nprint cat.Name\n\n// Output: Buttons\n\n\n\n\n\n\nWarning\n\n\nDo not depend on the destructor to always be called.\n\n\n\n\nMethod Modifiers\n\n\n\n\n\n\n Modifier \n\n\n Description \n\n\n\n\n\n\n \nabstract\n \n\n\n an \nabstract\n method has no implementation, which requires that an inheriting class implements it. \n\n\n\n\n\n\n \nstatic\n \n\n\n a \nstatic\n method is common to the entire \nclass\n, which means that it can be called without ownership of a single instance of the \nclass\n \n\n\n\n\n\n\n \nvirtual\n \n\n\n See \nPart 10 - Polymorphism, or Inherited Methods\n  \n\n\n\n\n\n\n \noverride\n \n\n\n See \nPart 10 - Polymorphism, or Inherited Methods\n \n\n\n\n\n\n\n\nAll these modifiers also apply to properties (If they are explicitly declared).\n\n\nstatic\n can also apply to fields.\n\n\nclass Animal:\n    def constructor():\n        _currentId += 1\n        _id = _currentId\n\n    [Getter(Id)]\n    _id as int\n\n    static _currentId = 0\n\n\n\n\nThis will cause the \nId\n to increase whenever an \nAnimal\n is instanced, giving each \nAnimal\n their own, unique \nId\n.\n\n\nAll the methods defined in an \ninterface\n are automatically declared abstract.\n\n\nAbstract\n methods in a \nclass\n must have a blank code block in its declaration.\n\n\nclass Feline:\n    abstract def Eat():\n        pass\n\ninterface IFeline:\n    def Eat()\n\n\n\n\nBoth declare roughly the same thing.\n\n\nMember Visibility\n\n\n\n\n\n\n Visibility Level \n\n\n Description \n\n\n\n\n\n\n \npublic\n \n\n\n Member is fully accessible to all types. \n\n\n\n\n\n\n \nprotected\n \n\n\n Member is only visible to this class and inheriting classes. \n\n\n\n\n\n\n \nprivate\n \n\n\n Member is only visible to this class. \n\n\n\n\n\n\n \ninternal\n \n\n\n Member is only visible to classes in the same assembly. \n\n\n\n\n\n\n\n\n\nNote\n\n\nImportant Information:\n All fields are by default \nprotected\n. All methods, properties, and events are by default \npublic\n.\n\n\n\n\n\n\nHint\n\n\nFields are typically either \nprotected\n or \nprivate\n. Usually instead of\nmaking a public field, you might make a public property that wraps access\nto the field instead. This allows subclasses to possibly override behavior.\n\n\n\n\nMethods can have any visibility.\n\n\nProperties can have any visibility, and typically have both a getter and a setter, or only a getter. Instead of a set only property, consider using a method instead (like \"SetSomeValue(val as int)\").\n\n\n\n\nHint\n\n\nIt is recommended you prefix field names with an underscore if it is a private field.\n\n\n\n\nDeclaring Properties in the Constructor\n\n\nOne very nice feature that boo offers is being able to declare the values of properties while they are being instanced.\n\n\nclass Box:\n    def constructor():\n        pass\n\n    [Property(Value)]\n    _value as object\n\nbox = Box(Value: 42)\nprint box.Value\n\n// Output: 42\n\n\n\n\nThe constructor didn't take any arguments, yet the \nValue: 42\n bit declared Value to be 42, all in a tighly compact, but highly readable space.\n\n\nExercises\n\n\n\n\nCreate two classes, \nPredator\n and \nPrey\n. To the \nPredator\n class, add an \nEat\n method that eats the \nPrey\n. Do not let the \nPrey\n be eaten twice.", 
            "title": "Methods"
        }, 
        {
            "location": "/Primer/Methods/#defining-a-method", 
            "text": "Methods must be defined in  classes . They are declared just like functions are.  class Cat:\n    def Roar():\n        print  Meow! \n\ncat = Cat()\ncat.Roar()\n\n// Output: Meow!  An object of  Cat  must be instanced, then its methods can be called.   Hint  Names of methods should always be verbs. They should also be declared in PascalCase.", 
            "title": "Defining a Method"
        }, 
        {
            "location": "/Primer/Methods/#class-constructor-and-destructor", 
            "text": "Constructors and Destructors are special methods that are called on when a  class  is being instanced or destroyed, respectively. Both are optional.  class Cat:\n    def constructor():\n        _name = 'Whiskers'\n\n    def destructor():\n        print  $_name is no more... RIP \n\n    [Getter(Name)]\n    _name as string\n\ncat = Cat()\nprint cat.Name\n\n// Output:\n// Whiskers\n// Whiskers is no more... RIP  If a constructor has arguments, then they must be supplied when instancing. Destructors cannot have arguments.  class Cat:\n    def constructor(name as string):\n        _name = name\n\n    [Getter(Name)]\n    _name as string\n\ncat = Cat( Buttons )\nprint cat.Name\n\n// Output: Buttons   Warning  Do not depend on the destructor to always be called.", 
            "title": "Class Constructor and Destructor"
        }, 
        {
            "location": "/Primer/Methods/#method-modifiers", 
            "text": "Modifier    Description       abstract     an  abstract  method has no implementation, which requires that an inheriting class implements it.       static     a  static  method is common to the entire  class , which means that it can be called without ownership of a single instance of the  class        virtual     See  Part 10 - Polymorphism, or Inherited Methods         override     See  Part 10 - Polymorphism, or Inherited Methods      All these modifiers also apply to properties (If they are explicitly declared).  static  can also apply to fields.  class Animal:\n    def constructor():\n        _currentId += 1\n        _id = _currentId\n\n    [Getter(Id)]\n    _id as int\n\n    static _currentId = 0  This will cause the  Id  to increase whenever an  Animal  is instanced, giving each  Animal  their own, unique  Id .  All the methods defined in an  interface  are automatically declared abstract.  Abstract  methods in a  class  must have a blank code block in its declaration.  class Feline:\n    abstract def Eat():\n        pass\n\ninterface IFeline:\n    def Eat()  Both declare roughly the same thing.", 
            "title": "Method Modifiers"
        }, 
        {
            "location": "/Primer/Methods/#member-visibility", 
            "text": "Visibility Level    Description       public     Member is fully accessible to all types.       protected     Member is only visible to this class and inheriting classes.       private     Member is only visible to this class.       internal     Member is only visible to classes in the same assembly.      Note  Important Information:  All fields are by default  protected . All methods, properties, and events are by default  public .    Hint  Fields are typically either  protected  or  private . Usually instead of\nmaking a public field, you might make a public property that wraps access\nto the field instead. This allows subclasses to possibly override behavior.   Methods can have any visibility.  Properties can have any visibility, and typically have both a getter and a setter, or only a getter. Instead of a set only property, consider using a method instead (like \"SetSomeValue(val as int)\").   Hint  It is recommended you prefix field names with an underscore if it is a private field.", 
            "title": "Member Visibility"
        }, 
        {
            "location": "/Primer/Methods/#declaring-properties-in-the-constructor", 
            "text": "One very nice feature that boo offers is being able to declare the values of properties while they are being instanced.  class Box:\n    def constructor():\n        pass\n\n    [Property(Value)]\n    _value as object\n\nbox = Box(Value: 42)\nprint box.Value\n\n// Output: 42  The constructor didn't take any arguments, yet the  Value: 42  bit declared Value to be 42, all in a tighly compact, but highly readable space.", 
            "title": "Declaring Properties in the Constructor"
        }, 
        {
            "location": "/Primer/Methods/#exercises", 
            "text": "Create two classes,  Predator  and  Prey . To the  Predator  class, add an  Eat  method that eats the  Prey . Do not let the  Prey  be eaten twice.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Polymorphism/", 
            "text": "Note\n\n\nPolymorphism\n - The ability for a new object to implement the base functionality of a parent object in a new way.\n\n\n\n\nTwo keywords are used to make Polymorphism happen: \nvirtual\n and \noverride\n.\n\n\nYou need to describe a method as \nvirtual\n if you want the ability to \noverride\n its capabilities.\n\n\nclass Rectangle:\n    def constructor(width as single, height as single):\n        _width = width\n        _height = height\n\n    virtual def GetArea():\n        return _width * _height\n\n    _width as single\n    _height as single\n\nclass Square(Rectangle):\n    def constructor(width as single):\n        super(width, width)\n\n    override def GetArea():\n        return _width * _width\n\nr = Rectangle(4.0, 6.0)\ns = Square(5.0)\n\nprint r.GetArea()\nprint s.GetArea()\nprint cast(Rectangle, s).GetArea()\n\n// Output:\n// 24.0\n// 25.0\n// 25.0\n\n\n\n\nEven when casted to a \nRectangle\n, s's \n.GetArea()\n functioned like if it were a \nSquare\n.\n\n\nAn easier example to see is this:\n\n\nclass Base:\n    virtual def Execute():\n        return 'From Base'\n\nclass Derived(Base):\n    override def Execute():\n        return 'From Derived'\n\nb = Base()\nd = Derived()\n\nprint b.Execute()\nprint d.Execute()\nprint cast(Base, d).Execute()\n\n// Output:\n// From Base\n// From Derived\n// From Derived\n\n\n\n\nIf I were to leave out the \nvirtual\n and \noverride\n keywords,\n\n\n// Output:\n// From Base\n// From Derived\n// From Base\n\n\n\n\nThis happens because unless the base method is \nvirtual\n or \nabstract\n, the derived method cannot be declared as \noverride\n.\n\n\n\n\nHint\n\n\nAlthough you do not have to explicitly declare a method as override when inheriting\nfrom a virtual method, you should anyway, in case the signatures of the virtual and\noverriding methods do not match.\n\n\n\n\nIn order to \noverride\n, the base function must be declared as \nvirtual\n or \nabstract\n, have the same return type, and accept the same arguments.\n\n\nPolymorphism is very handy when dealing with multiple types derived from the same base.\n\n\ninterface IAnimal:\n    def MakeNoise()\n\nclass Dog(IAnimal):\n    def MakeNoise():\n        print 'Woof'\n\nclass Cat(IAnimal):\n    def MakeNoise():\n        print 'Meow'\n\nclass Hippo(IAnimal):\n    def MakeNoise():\n        print '*Noise of a Hippo*'\n\nlist = []\nlist.Add(Dog())\nlist.Add(Cat())\nlist.Add(Hippo())\n\nfor animal as IAnimal in list:\n    animal.MakeNoise()\n\n// Output:\n// Woof\n// Meow\n// *Noise of a Hippo*\n\n\n\n\nVery handy.\n\n\nExercises\n\n\n\n\nFigure out an exercise", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/Primer/Polymorphism/#exercises", 
            "text": "Figure out an exercise", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Structs/", 
            "text": "Note\n\n\nStruct\n - Short for structure, a term meaning a data group made of related variables.\n\n\n\n\nThe main way \nstructs\n are different than \nclasses\n is that they are value types instead of a reference types. This means that whenever you return this value, or set one equal to another, it is actually copying the data not a reference to the data. This is handy, because if it is declared without a value, it will default to something besides \nnull\n. It also cannot be compared to \nnull\n. This eliminates a lot of error checking associated with reference types.\n\n\nStructs\n also cannot inherit from \nclasses\n, nor can \nclasses\n inherit from \nstructs\n. \nStructs\n can however, inherit from \ninterfaces\n.\n\n\nUnlike some other languages, \nstructs\n can have methods.\n\n\nDeclaring a Struct\n\n\nDeclaring a struct is very similar to declaring a \nclass\n, except that the name is changed.\n\n\nstruct Coordinate:\n    def constructor(x as int, y as int):\n        _x = x\n        _y = y\n\n    _x as int\n    _y as int\n\nc as Coordinate\nprint c._x, c._y\nc = Coordinate(3, 5)\nprint c._x, c._y\n\n// Output:\n// 0 0\n// 3 5\n\n\n\n\nHere you can see that the \nstruct\n was instanced without being called, showing the how a \nstruct\n is a value.\n\n\nExercises\n\n\n\n\nFigure out a good exercise for this section.", 
            "title": "Structs"
        }, 
        {
            "location": "/Primer/Structs/#declaring-a-struct", 
            "text": "Declaring a struct is very similar to declaring a  class , except that the name is changed.  struct Coordinate:\n    def constructor(x as int, y as int):\n        _x = x\n        _y = y\n\n    _x as int\n    _y as int\n\nc as Coordinate\nprint c._x, c._y\nc = Coordinate(3, 5)\nprint c._x, c._y\n\n// Output:\n// 0 0\n// 3 5  Here you can see that the  struct  was instanced without being called, showing the how a  struct  is a value.", 
            "title": "Declaring a Struct"
        }, 
        {
            "location": "/Primer/Structs/#exercises", 
            "text": "Figure out a good exercise for this section.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Namespaces/", 
            "text": "Note\n\n\nNamespace\n - A name that uniquely identifies a set of objects so there is no ambiguity\nwhen objects from different sources are used together.\n\n\n\n\nNamespaces\n are useful because if you have, for example, a \nDog\n namespace and a \nFurniture namespace\n, and they both have a \nLeg class\n, you can refer to \nDog.Leg\n and \nFurniture.Leg\n and be clear about which \nclass\n you are mentioning.\n\n\nDeclaring a Namespace\n\n\nTo declare a \nnamespace\n, all that is required is that you put \nnamespace\n followed by a name at the top of your file.\n\n\nnamespace Tutorial\n\nclass Thing():\n    pass\n\n\n\n\nThis creates your class \nTutorial.Thing\n. While coding inside your \nnamespace\n, it will be transparently Thing.\nTo declare a \nnamespace\n within a \nnamespace\n, just place a dot . inbetween each other.\n\n\n\n\nHint\n\n\nDeclare a namespace at the top of all your files. Use PascalCase for all your namespaces.\n\n\n\n\nImporting Another Namespace\n\n\nTo use \nclasses\n from another \nnamespace\n, you would use the \nimport\n keyword.\n\n\nThe most common \nnamespace\n you will import is \nSystem\n.\n\n\nimport System\nConsole.WriteLine()\n\n\n\n\nnot importing from a namespace:\n\n\nSystem.Console.WriteLine()\n\n\n\n\nBoth produce the exact same code, it's just easier and clearer with the \nimport\n.\n\n\n\n\nHint\n\n\nDon't be afraid to import, just don't import namespaces that you aren't using.\n\n\n\n\n\n\nHint\n\n\nWhen importing, import included namespaces first, such as \nSystem\n or \nBoo.Lang\n. Then import\nyour 3rd party namespaces. Alphabetize the two groups seperately.\n\n\n\n\nIf you are importing from another assembly, you would use the phrase \nimport \ntarget\n from \nassembly\n, for example\n\n\nimporting from an external assembly:\n\n\nimport System.Data from System.Data\nimport Gtk from \ngtk-sharp\n\n\n\n\n\nSystem.Data\n is part of an external library which can be added, \nSystem.Data.dll\n. \nGtk\n is part of the Gtk# library, which, since it has a special name (with a dash in it), it must be quoted.\n\n\n\n\nHint\n\n\nOnly use the \nimport \ntarget\n from \nassembly\n if you are using one file and one file only. If you are using more than that, you should be using a build tool, such as \nNAnt\n, which is discussed in \nPart 19 - Using the Boo Compiler\n.\n\n\n\n\nExercises\n\n\n\n\nFigure out a good exercise for this section.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/Primer/Namespaces/#declaring-a-namespace", 
            "text": "To declare a  namespace , all that is required is that you put  namespace  followed by a name at the top of your file.  namespace Tutorial\n\nclass Thing():\n    pass  This creates your class  Tutorial.Thing . While coding inside your  namespace , it will be transparently Thing.\nTo declare a  namespace  within a  namespace , just place a dot . inbetween each other.   Hint  Declare a namespace at the top of all your files. Use PascalCase for all your namespaces.", 
            "title": "Declaring a Namespace"
        }, 
        {
            "location": "/Primer/Namespaces/#importing-another-namespace", 
            "text": "To use  classes  from another  namespace , you would use the  import  keyword.  The most common  namespace  you will import is  System .  import System\nConsole.WriteLine()  not importing from a namespace:  System.Console.WriteLine()  Both produce the exact same code, it's just easier and clearer with the  import .   Hint  Don't be afraid to import, just don't import namespaces that you aren't using.    Hint  When importing, import included namespaces first, such as  System  or  Boo.Lang . Then import\nyour 3rd party namespaces. Alphabetize the two groups seperately.   If you are importing from another assembly, you would use the phrase  import  target  from  assembly , for example  importing from an external assembly:  import System.Data from System.Data\nimport Gtk from  gtk-sharp   System.Data  is part of an external library which can be added,  System.Data.dll .  Gtk  is part of the Gtk# library, which, since it has a special name (with a dash in it), it must be quoted.   Hint  Only use the  import  target  from  assembly  if you are using one file and one file only. If you are using more than that, you should be using a build tool, such as  NAnt , which is discussed in  Part 19 - Using the Boo Compiler .", 
            "title": "Importing Another Namespace"
        }, 
        {
            "location": "/Primer/Namespaces/#exercises", 
            "text": "Figure out a good exercise for this section.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Enumerations/", 
            "text": "Note\n\n\nEnumeration\n - A set of name to integer value associations.\n\n\n\n\nDeclaring an Enumeration\n\n\nEnumerations are handy to use as fields and properties in \nclasses\n.\n\n\nenum Day:\n    Sunday\n    Monday\n    Tuesday\n    Wednesday\n    Thursday\n    Friday\n    Saturday\n\nclass Action:\n    [Property(Day)]\n    _day as Day\n\n\n\n\nEnumerations are also handy in preventing \"magic numbers\", which can cause unreadable code.\n\n\n\n\nNote\n\n\nMagic Number\n - Any number outside of -1, 0, 1, or 2.\n\n\n\n\nEnumerations technically assign an integer value to each value, but that should generally be abstracted from view.\n\n\nenum Test:\n    Alpha\n    Bravo\n    Charlie\n\n// is the same as\n\nenum Test:\n    Alpha = 0\n    Bravo = 1\n    Charlie = 2\n\n\n\n\n\n\nHint\n\n\nExcept in special cases, do not assign numbers.\n\n\n\n\nExercises\n\n\n\n\nThink of another good instance of using enums.", 
            "title": "Enumerations"
        }, 
        {
            "location": "/Primer/Enumerations/#declaring-an-enumeration", 
            "text": "Enumerations are handy to use as fields and properties in  classes .  enum Day:\n    Sunday\n    Monday\n    Tuesday\n    Wednesday\n    Thursday\n    Friday\n    Saturday\n\nclass Action:\n    [Property(Day)]\n    _day as Day  Enumerations are also handy in preventing \"magic numbers\", which can cause unreadable code.   Note  Magic Number  - Any number outside of -1, 0, 1, or 2.   Enumerations technically assign an integer value to each value, but that should generally be abstracted from view.  enum Test:\n    Alpha\n    Bravo\n    Charlie\n\n// is the same as\n\nenum Test:\n    Alpha = 0\n    Bravo = 1\n    Charlie = 2   Hint  Except in special cases, do not assign numbers.", 
            "title": "Declaring an Enumeration"
        }, 
        {
            "location": "/Primer/Enumerations/#exercises", 
            "text": "Think of another good instance of using enums.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Functions-as-objects/", 
            "text": "Having Functions act as \nobjects\n exposes three very useful methods:\n\n\n\n\nfunction.Invoke(\narguments\n) as \nreturn type\n\n\nfunction.BeginInvoke(\narguments\n) as IAsyncResult\n\n\nfunction.EndInvoke(IAsyncResult) as \nreturn type\n\n\n\n\n.Invoke\n just calls the function normally and acts like it was called with just regular parentheses ().\n\n\n.BeginInvoke\n starts a seperate thread that does nothing but run the function invoked.\n\n\n.EndInvoke\n finishes up the previously invoked function and returns the proper return type.\n\n\ndef Nothing(x):\n    return x\n\ni = 5\nassert 5 == Nothing(i)\nassert i == Nothing.Invoke(i)\nassert i == Nothing.Invoke.Invoke(i)\n\n\n\n\nSince \n.Invoke\n is a function itself, it has its own \n.Invoke\n.\n\n\nHere's a good example of .BeginInvoke\n\n\nMultithreading with .BeginInvoke\n\n\nimport System\nimport System.Threading\n\nclass FibonacciCalculator:\n    def constructor():\n        _alpha, _beta = 0, 1\n        _stopped = true\n\n    def Calculate():\n        _stopped = false\n        while not _stopped:\n            Thread.Sleep(200)\n            _alpha, _beta = _beta, _alpha + _beta\n            print _beta\n\n    def Start():\n        _result = Calculate.BeginInvoke()\n\n    def Stop():\n        _stopped = true\n        Calculate.EndInvoke(_result)\n\n    _result as IAsyncResult\n\n    _alpha as ulong\n    _beta as ulong\n\n    _stopped as bool\n\nfib = FibonacciCalculator()\nfib.Start()\nprompt(\nPress enter to stop...\\n\n)\nfib.Stop()\n\n\n\n\nThe output produces the Fibonacci sequence roughly every 200 milliseconds (because that's what the delay is). This will produce an overflow after it gets up to 2^64.\n\n\nThe important thing is that it stops cleanly if you press Enter.\n\n\nExercises\n\n\n\n\nThink of an exercise", 
            "title": "Functions as objects"
        }, 
        {
            "location": "/Primer/Functions-as-objects/#exercises", 
            "text": "Think of an exercise", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Generators/", 
            "text": "Generator Expressions\n\n\n\n\nNote\n\n\nGenerator Expression\n - A phrase that creates a generator based on the syntax: \n\nexpression\n for \ndeclarations\n [as \ntype\n] in \niterator\n [if|unless \ncondition\n]\n\n\n\n\nGenerator Expressions have similar syntax to the \nfor\n loops that we have covered, and serve a similar purpose.\n\n\nThe best way to learn how to use Generator Expressions is by example, so here we load up a booish prompt.\n\n\n$ booish\n\n List(x for x in range(5)) // simplest Generator Expression\n[0, 1, 2, 3, 4]\n\n List(x * 2 for x in range(5)) // get double of values\n[0, 2, 4, 6, 8]\n\n List(x**2 for x in range(5)) // get square of values\n[0, 1, 4, 9, 16]\n\n List(x for x in range(5) if x % 2 == 0) // check if values are even\n[0, 2, 4]\n\n List(x for x in range(10) if x % 2 == 0) // check if values are even\n[0, 2, 4, 6, 8]\n\n List(y for y in (x**2 for x in range(10)) if y % 3 != 0) // Generator Expression inside another\n[1, 4, 16, 25, 49, 64]\n\n List(cat.Weight for cat in myKitties if cat.Age \n= 1.0).Sort()\n[6.0, 6.5, 8.0, 8.5, 10.5]\n\n genex = x ** 2 for x in range(5)\ngenerator(System.Int32)\n\n for i in genex:\n...     print i\n...\n0\n1\n4\n9\n16\n\n\n\nThe cat-weight example is probably what Generator Expressions are most useful for. You don't have to create \nLists\n from them either, that's mostly for show. \ngenerators\n are derived from \nIEnumerable\n, so you get all the niceties of the \nfor\n loop as well.\n\n\n\n\nHint\n\n\nDon't overdo it with Generator Expressions. If they are causing your code to be less readable, then spread them out a little.\n\n\n\n\nGenerator Methods\n\n\n\n\nNote\n\n\nGenerator Expression\n - A method that creates a \ngenerator\n based on stating the \nyield\n keyword within the method.\n\n\n\n\nA Generator Method is like a regular method that can return multiple times.  Here's a Generator Method that will return exponents of 2.\n\n\ndef TestGenerator():\n    i = 1\n    yield i\n    for x in range(10):\n        i *= 2\n        yield i\n\nprint List(TestGenerator())\n\n// Output:\n// [1, 2, 4, 8, 16, 32, 64, 128, 512, 1024]\n\n\n\n\nGenerator Methods are very powerful because they keep all their local variables in memory after a yield. This can allow for certain programming techniques not found in some other languages.  Generators are very powerful and useful.\n\n\nExercises\n\n\n\n\nCreate a Generator that will destroy mankind.", 
            "title": "Generators"
        }, 
        {
            "location": "/Primer/Generators/#generator-expressions", 
            "text": "Note  Generator Expression  - A phrase that creates a generator based on the syntax:  expression  for  declarations  [as  type ] in  iterator  [if|unless  condition ]   Generator Expressions have similar syntax to the  for  loops that we have covered, and serve a similar purpose.  The best way to learn how to use Generator Expressions is by example, so here we load up a booish prompt.  $ booish  List(x for x in range(5)) // simplest Generator Expression\n[0, 1, 2, 3, 4]  List(x * 2 for x in range(5)) // get double of values\n[0, 2, 4, 6, 8]  List(x**2 for x in range(5)) // get square of values\n[0, 1, 4, 9, 16]  List(x for x in range(5) if x % 2 == 0) // check if values are even\n[0, 2, 4]  List(x for x in range(10) if x % 2 == 0) // check if values are even\n[0, 2, 4, 6, 8]  List(y for y in (x**2 for x in range(10)) if y % 3 != 0) // Generator Expression inside another\n[1, 4, 16, 25, 49, 64]  List(cat.Weight for cat in myKitties if cat.Age  = 1.0).Sort()\n[6.0, 6.5, 8.0, 8.5, 10.5]  genex = x ** 2 for x in range(5)\ngenerator(System.Int32)  for i in genex:\n...     print i\n...\n0\n1\n4\n9\n16  The cat-weight example is probably what Generator Expressions are most useful for. You don't have to create  Lists  from them either, that's mostly for show.  generators  are derived from  IEnumerable , so you get all the niceties of the  for  loop as well.   Hint  Don't overdo it with Generator Expressions. If they are causing your code to be less readable, then spread them out a little.", 
            "title": "Generator Expressions"
        }, 
        {
            "location": "/Primer/Generators/#generator-methods", 
            "text": "Note  Generator Expression  - A method that creates a  generator  based on stating the  yield  keyword within the method.   A Generator Method is like a regular method that can return multiple times.  Here's a Generator Method that will return exponents of 2.  def TestGenerator():\n    i = 1\n    yield i\n    for x in range(10):\n        i *= 2\n        yield i\n\nprint List(TestGenerator())\n\n// Output:\n// [1, 2, 4, 8, 16, 32, 64, 128, 512, 1024]  Generator Methods are very powerful because they keep all their local variables in memory after a yield. This can allow for certain programming techniques not found in some other languages.  Generators are very powerful and useful.", 
            "title": "Generator Methods"
        }, 
        {
            "location": "/Primer/Generators/#exercises", 
            "text": "Create a Generator that will destroy mankind.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Macros/", 
            "text": "print Macro\n\n\nThe \nprint\n Macro will display one or more objects to the screen.\n\n\nThere are two ways to call the \nprint\n macro.\n\n\n\n\nWith only one argument\n\n\nWith two or more arguments\n\n\n\n\nprint \nHello there\n\nprint \nHello\n, \nthere\n\n\n// Output:\n// Hello there\n// Hello there\n\n\n\n\nIn the second case, for every case except the last, it will write the string to the screen, write a space, then move on. In the end, the two will have the same end result.\n\n\nassert Macro\n\n\nThe \nassert\n Macro makes sure that a condition is true, otherwise it raises an \nAssertionFailedException\n.\n\n\nassert\n can be called with one or two arguments.\n\n\n\n\nThe first argument must always be a boolean condition.\n\n\nThe optional second argument is a string that will be sent if the condition fails.\n\n\n\n\nassert true // this will always pass\nassert false, \nmessage\n // this will always fail\n\n// Output:\n// Boo.Lang.Runtime.AssertionFailedException: message\n//    at Tutorial.Main(String[] argv)\n\n\n\n\n\n\nHint\n\n\nNever \nassert\n a condition that would, in itself, change your code. e.g. \nassert iter.MoveNext()\n would be a bad idea.\n\n\n\n\nusing Macro\n\n\nThe \nusing\n Macro can take any number of arguments, it merely duplicates its behavior each time. It creates a safety net for objects to be handled during a block, then disposed of as soon as that block is finished.\n\n\nThere are three types of arguments you can declare:\n1. \nobject\n\n2. \nobject\n = \nexpression\n\n3. \nexpression\n\n\nIn all three of these, it checks if the underlying \nobject\n is an \nIDisposable\n, which it then disposes of afterward.\n\n\nimport System.IO\n\nusing w = StreamWriter(\ntest.txt\n):\n    w.WriteLine(\nHello there!\n)\n\n\n\n\nThis will create the file, write to it, then close it as soon as the \nusing\n block is finished. Makes it very safe and convenient.\n\n\nlock Macro\n\n\nThe \nlock\n Macro makes sure that, in a multithreaded environment, that a specified object is not being used and prevents another object from using it at the same time.\n\n\nlock\n must accept at least one argument, and it will put the \nlock\n on all that are given.\n\n\nlock database:\n    database.Execute(\n\n        UPDATE messages\n        SET\n            id = id + 1\n)\n\n\n\n\ndebug Macro\n\n\nThe \ndebug\n Macro is the exact same as the \nprint\n Macro, except that it sends its messages to \nSystem.Diagnostics.Debug\n instead of \nSystem.Console\n.", 
            "title": "Macros"
        }, 
        {
            "location": "/Primer/Macros/#print-macro", 
            "text": "The  print  Macro will display one or more objects to the screen.  There are two ways to call the  print  macro.   With only one argument  With two or more arguments   print  Hello there \nprint  Hello ,  there \n\n// Output:\n// Hello there\n// Hello there  In the second case, for every case except the last, it will write the string to the screen, write a space, then move on. In the end, the two will have the same end result.", 
            "title": "print Macro"
        }, 
        {
            "location": "/Primer/Macros/#assert-macro", 
            "text": "The  assert  Macro makes sure that a condition is true, otherwise it raises an  AssertionFailedException .  assert  can be called with one or two arguments.   The first argument must always be a boolean condition.  The optional second argument is a string that will be sent if the condition fails.   assert true // this will always pass\nassert false,  message  // this will always fail\n\n// Output:\n// Boo.Lang.Runtime.AssertionFailedException: message\n//    at Tutorial.Main(String[] argv)   Hint  Never  assert  a condition that would, in itself, change your code. e.g.  assert iter.MoveNext()  would be a bad idea.", 
            "title": "assert Macro"
        }, 
        {
            "location": "/Primer/Macros/#using-macro", 
            "text": "The  using  Macro can take any number of arguments, it merely duplicates its behavior each time. It creates a safety net for objects to be handled during a block, then disposed of as soon as that block is finished.  There are three types of arguments you can declare:\n1.  object \n2.  object  =  expression \n3.  expression  In all three of these, it checks if the underlying  object  is an  IDisposable , which it then disposes of afterward.  import System.IO\n\nusing w = StreamWriter( test.txt ):\n    w.WriteLine( Hello there! )  This will create the file, write to it, then close it as soon as the  using  block is finished. Makes it very safe and convenient.", 
            "title": "using Macro"
        }, 
        {
            "location": "/Primer/Macros/#lock-macro", 
            "text": "The  lock  Macro makes sure that, in a multithreaded environment, that a specified object is not being used and prevents another object from using it at the same time.  lock  must accept at least one argument, and it will put the  lock  on all that are given.  lock database:\n    database.Execute( \n        UPDATE messages\n        SET\n            id = id + 1 )", 
            "title": "lock Macro"
        }, 
        {
            "location": "/Primer/Macros/#debug-macro", 
            "text": "The  debug  Macro is the exact same as the  print  Macro, except that it sends its messages to  System.Diagnostics.Debug  instead of  System.Console .", 
            "title": "debug Macro"
        }, 
        {
            "location": "/Primer/Duck-typing/", 
            "text": "Note\n\n\nDuck Typing\n - Duck typing is a humorous way of describing the type non-checking system. Initially coined by Dave Thomas in the Ruby community, its premise is that (referring to a value) \"if it walks like a duck, and talks like a duck, then it is a duck\".\n\n\n\n\nEven though Boo is a statically typed language, Duck Typing is a way to fake being a dynamic language. Duck typing allows variables to be recognized at runtime, instead of compile time. Though this can add a sense of simplicity, it does remove a large security barrier.\n\n\nd as duck\nd = 5 // currently set to an integer.\nprint d\nd += 10 // It can do everything an integer does.\nprint d\nd = \nHi there\n // sets it to a string.\nprint d\nd = d.ToUpper() // It can do everything a string does.\nprint d\n\n// Output:\n// 5\n// 15\n// Hi there\n// HI THERE\n\n\n\n\nDuck typing is very handy if you are loading from a factory or an unpredictable dynamic library.\n\n\n\n\nHint\n\n\nDo not enable duck typing by default. It should only be used in a few situations.\n\n\n\n\nOn a side note, The \nbooish\n interpreter has duck typing enabled by default. This can be disabled by typing in \ninterpreter.Ducky = false\n\n\nHere is a practical example of where duck typing is useful.\n\n\nPractical Duck Typing:\n\n\nimport System.Threading\n\ndef CreateInstance(progid):\n    type = System.Type.GetTypeFromProgID(progid)\n    return type()\n\nie as duck = CreateInstance(\nInternetExplorer.Application\n)\nie.Visible = true\nie.Navigate2(\nhttp://www.go-mono.com/monologue/\n)\n\nwhile ie.Busy:\n    Thread.Sleep(50ms)\n\ndocument = ie.Document\nprint(\n$(document.title) is $(document.fileSize) bytes long.\n)\n\n\n\n\nExercises\n\n\n\n\nCome up with another good example where duck typing is effective.", 
            "title": "Duck typing"
        }, 
        {
            "location": "/Primer/Duck-typing/#exercises", 
            "text": "Come up with another good example where duck typing is effective.", 
            "title": "Exercises"
        }, 
        {
            "location": "/Primer/Using-the-compiler/", 
            "text": "The Boo Compiler is typically called in this fashion:\n\n\nbooc \noptions\n \nfiles\n\n\nCompiler Options\n\n\n\n\n\n\n Option \n\n\n Description \n\n\n\n\n\n\n \n-v\n \n\n\n Verbose \n\n\n\n\n\n\n \n-vv\n \n\n\n More Verbose \n\n\n\n\n\n\n \n-vvv\n \n\n\n Most Verbose \n\n\n\n\n\n\n \n-r:\nreference_name\n \n\n\n Add a reference to your project \n\n\n\n\n\n\n \n-t:\ntype_name_to_generate\n \n\n\n Type of file to generate, can be either \nexe\n or \nwinexe\n to make executables (.exe files), or \nlibrary\n to make a .dll file \n\n\n\n\n\n\n \n-p:\npipeline\n \n\n\n Adds a step \npipeline\n to the compile. \n\n\n\n\n\n\n \n-c:\nculture\n \n\n\n Sets which \nCultureInfo\n to use. \n\n\n\n\n\n\n \n-o:\noutput_file\n \n\n\n Sets the name of the output file \n\n\n\n\n\n\n \n-srcdir:\nsource_files\n \n\n\n Specify where to find the source files. \n\n\n\n\n\n\n \n-debug\n \n\n\n Adds debug flags to your code. Good for non-production. (On by default) \n\n\n\n\n\n\n \n-debug-\n \n\n\n Does not add debug flags to your code. Good for production environment. \n\n\n\n\n\n\n \n-debug-steps\n \n\n\n See AST after each compilation step. \n\n\n\n\n\n\n \n-resource:\nresource_file\n,\nname\n \n\n\n Add a resource file. \nname\n is optional. \n\n\n\n\n\n\n \n-embedres:\nresource_file\n,\nname\n \n\n\n Add an embedded resource file. \nname\n is optional. \n\n\n\n\n\n\n\nUsing NAnt\n\n\nWhen working on a large project with multiple files or libraries, it is a lot easier to use \nNAnt\n. It is a free .NET build tool.\n\n\nTo do the same command as above, you would create the following build file:\n\n\n?xml version=\n1.0\n ?\n\n\n\nproject name=\nGoomba\n default=\nbuild\n\n    \ntarget name=\nbuild\n depends=\ndatabase\n /\n\n    \ntarget name=\ndatabase\n\n        \nmkdir dir=\nbin\n /\n\n        \nbooc output=\nbin/Database.dll\n target=\nlibrary\n\n            \nreferences basedir=\nbin\n\n                \ninclude name=\nSystem.Data.dll\n /\n\n            \n/references\n\n            \nsources\n\n                \ninclude name=\nDatabase.boo\n /\n\n            \n/sources\n\n        \n/booc\n\n    \n/target\n\n\n/project\n\n\n\n\n\n$ nant\nNAnt 0.85 (Build 0.85.1869.0; rc2; 2/12/2005)\nCopyright (C) 2001-2005 Gerry Shaw\nhttp://nant.sourceforge.net\n\nBuildfile: file:///path/to/default.build\nTarget framework: Microsoft .NET Framework 1.1\nTarget(s) specified: build\n\nbuild:\n\ndatabase:\n\n     [booc] Compiling 1 file(s) to /path/to/bin/Database.dll.\n\nBUILD SUCCEEDED\n\nTotal time: 0.2 seconds.\n\n\n\nAnd although that was a long and drawnout version of something so simple, it does make things a lot easier when dealing with multiple files. It also helps that if you make a change to your source files, you don't have to type a long \nbooc\n phrase over again. The important part of the build file is the \nbooc\n section. It relays commands to the compiler.\n\n\nThere are four attributes available to use in it:\n\n\n\n\n\n\n Attribute \n\n\n Description \n\n\n\n\n\n\n \ntarget\n \n\n\n Output type, one of \nlibrary\n, \nexe\n, \nwinexe\n. Optional. Default: \nexe\n. \n\n\n\n\n\n\n \noutput\n \n\n\n The name of the output assembly. \nRequired\n. \n\n\n\n\n\n\n \npipeline\n \n\n\n AssemblyQualifiedName for the CompilerPipeline type to use. Optional. \n\n\n\n\n\n\n \ntracelevel\n \n\n\n Enables compiler tracing, useful for debugging the compiler, one of: Off, Error, Warning, Info, Verbose. Optional. Default: Off. \n\n\n\n\n\n\n\nYou are most likely only to use \ntarget\n and \noutput\n.\n\n\nFor nested elements, you have 3 possibilities:\n\n\n\n\n\n\n Nested Element \n\n\n Description \n\n\n\n\n\n\n \nsources\n \n\n\n Source files. \nRequired\n. \n\n\n\n\n\n\n \nreferences\n \n\n\n Assembly references. \n\n\n\n\n\n\n \nresources\n \n\n\n Embedded resources. \n\n\n\n\n\n\n\nInside these you are to put \n elements, as in the example.\n\n\nThis is merely a brief overview of NAnt, please go to their website \nhttp://nant.sourceforge.net\n for more information.", 
            "title": "Using the compiler"
        }, 
        {
            "location": "/Primer/Using-the-compiler/#compiler-options", 
            "text": "Option    Description       -v     Verbose       -vv     More Verbose       -vvv     Most Verbose       -r: reference_name     Add a reference to your project       -t: type_name_to_generate     Type of file to generate, can be either  exe  or  winexe  to make executables (.exe files), or  library  to make a .dll file       -p: pipeline     Adds a step  pipeline  to the compile.       -c: culture     Sets which  CultureInfo  to use.       -o: output_file     Sets the name of the output file       -srcdir: source_files     Specify where to find the source files.       -debug     Adds debug flags to your code. Good for non-production. (On by default)       -debug-     Does not add debug flags to your code. Good for production environment.       -debug-steps     See AST after each compilation step.       -resource: resource_file , name     Add a resource file.  name  is optional.       -embedres: resource_file , name     Add an embedded resource file.  name  is optional.", 
            "title": "Compiler Options"
        }, 
        {
            "location": "/Primer/Using-the-compiler/#using-nant", 
            "text": "When working on a large project with multiple files or libraries, it is a lot easier to use  NAnt . It is a free .NET build tool.  To do the same command as above, you would create the following build file:  ?xml version= 1.0  ?  project name= Goomba  default= build \n     target name= build  depends= database  / \n     target name= database \n         mkdir dir= bin  / \n         booc output= bin/Database.dll  target= library \n             references basedir= bin \n                 include name= System.Data.dll  / \n             /references \n             sources \n                 include name= Database.boo  / \n             /sources \n         /booc \n     /target  /project   $ nant\nNAnt 0.85 (Build 0.85.1869.0; rc2; 2/12/2005)\nCopyright (C) 2001-2005 Gerry Shaw\nhttp://nant.sourceforge.net\n\nBuildfile: file:///path/to/default.build\nTarget framework: Microsoft .NET Framework 1.1\nTarget(s) specified: build\n\nbuild:\n\ndatabase:\n\n     [booc] Compiling 1 file(s) to /path/to/bin/Database.dll.\n\nBUILD SUCCEEDED\n\nTotal time: 0.2 seconds.  And although that was a long and drawnout version of something so simple, it does make things a lot easier when dealing with multiple files. It also helps that if you make a change to your source files, you don't have to type a long  booc  phrase over again. The important part of the build file is the  booc  section. It relays commands to the compiler.  There are four attributes available to use in it:     Attribute    Description       target     Output type, one of  library ,  exe ,  winexe . Optional. Default:  exe .       output     The name of the output assembly.  Required .       pipeline     AssemblyQualifiedName for the CompilerPipeline type to use. Optional.       tracelevel     Enables compiler tracing, useful for debugging the compiler, one of: Off, Error, Warning, Info, Verbose. Optional. Default: Off.     You are most likely only to use  target  and  output .  For nested elements, you have 3 possibilities:     Nested Element    Description       sources     Source files.  Required .       references     Assembly references.       resources     Embedded resources.     Inside these you are to put   elements, as in the example.  This is merely a brief overview of NAnt, please go to their website  http://nant.sourceforge.net  for more information.", 
            "title": "Using NAnt"
        }, 
        {
            "location": "/Primer/Structure-of-a-project/", 
            "text": "On the Project-level\n\n\nHere I'll use the example of the IRC bot I write: Goomba\n\n\n+ Goomba (Goomba namespace)\n   |+ Configuration (Goomba.Configuration namespace)\n   |   |- Config.boo\n   |       |# class Config\n   |+ Data (Goomba.Data namespace)\n   |   |- Column.boo\n   |   |   |# class Column\n   |   |- Database.boo\n   |   |   |# enum DatabaseType\n   |   |   |# class Database\n   |   |- DatabasePreferences.boo\n   |   |   |# class DatabasePreferences\n   |   |- Result.boo\n   |       |# class Result\n   |+ Plugins (Goomba.Plugins namespace)\n   |   |- DefineCommand.boo\n   |   |   |# class DefineCommand\n   |   |       |# class Definition\n   |   |- Hail.boo\n   |   |   |# class Hail\n   |   |       |# class HailMessage\n   |   |- HelpCommand.boo\n   |   |   |# class HelpCommand\n   |   |- Logger.boo\n   |   |   |# class Logger\n   |   |       |# class Message\n   |   |       |# class Action\n   |   |- Quoter.boo\n   |   |   |# class Quoter\n   |   |       |# class Quote\n   |   |- RawLogger.boo\n   |   |   |# class RawLogger\n   |   |- UrlGenerator.boo\n   |   |   |# class UrlGenerator\n   |   |       |# class Engine\n   |   |- UserTracker.boo\n   |   |   |# class UserTracker\n   |   |       |# class User\n   |   |- VersionCommand.boo\n   |   |   |# class VersionCommand\n   |   |- UrlTracker.boo\n   |       |# class UrlTracker\n   |           |# class Url\n   |- ActionEventArgs.boo\n   |   |# enum ActionType\n   |   |# class ActionEventArgs\n   |- DebugLogger.boo\n   |   |# enum LogImportance\n   |   |# class DebugLogger\n   |- Goomba.boo\n   |   |# class Goomba\n   |   |! Main Body (This will be executed when Goomba.exe is run)\n   |- GoombaPreferences.boo\n   |   |# class GoombaPreferences\n   |- IPlugin.boo\n   |   |# interface IPlugin\n   |- MessageEventArgs.boo\n   |   |# enum MessageType\n   |   |# class MessageEventArgs\n   |- Sender.boo\n       |# enum SenderType\n       |# class Sender\n\n\n\nWhich I have set up to create the assemblies \nGoomba.exe\n, \nGoomba.Data.dll\n, \nGoomba.Configuration.dll\n, as well as one assembly per plugin.\n\n\nYou may have noticed a few important things:\n\n\n\n\nFor every directory, it represents a different namespace, with the same name as the directory itself.\n\n\nEach \n.boo\n file has at most one class in it. That class will have the \nsame exact\n name as the \n.boo\n file.\n\n\nThe \"Main Body\" section is below the \nclass\n Goomba definition. Any inline executable code must be at the bottom of a file in the assembly.\n\n\nEnums\n come before classes. This is merely a coding practice that is not required, but recommended. If an \nenum\n is larger than 15 values, place it in its own file.\n\n\n\n\nOn the File-level\n\n\nFiles must be defined in this order:\n\n\n\n\nModule docstring\n\n\nNamespace declaration\n\n\nImport statements\n\n\nEnums/Classes/Structs/Interfaces\n\n\nFunctions\n\n\nMain code executed when script is run\n\n\nAssembly attributes\n\n\n\n\n\n\nHint\n\n\nOne class per file. If you have more than one class per file, split it up. If you have a class inside another class, this is acceptable, as it still has one flat class per file.", 
            "title": "Structure of a project"
        }, 
        {
            "location": "/Primer/Structure-of-a-project/#on-the-project-level", 
            "text": "Here I'll use the example of the IRC bot I write: Goomba  + Goomba (Goomba namespace)\n   |+ Configuration (Goomba.Configuration namespace)\n   |   |- Config.boo\n   |       |# class Config\n   |+ Data (Goomba.Data namespace)\n   |   |- Column.boo\n   |   |   |# class Column\n   |   |- Database.boo\n   |   |   |# enum DatabaseType\n   |   |   |# class Database\n   |   |- DatabasePreferences.boo\n   |   |   |# class DatabasePreferences\n   |   |- Result.boo\n   |       |# class Result\n   |+ Plugins (Goomba.Plugins namespace)\n   |   |- DefineCommand.boo\n   |   |   |# class DefineCommand\n   |   |       |# class Definition\n   |   |- Hail.boo\n   |   |   |# class Hail\n   |   |       |# class HailMessage\n   |   |- HelpCommand.boo\n   |   |   |# class HelpCommand\n   |   |- Logger.boo\n   |   |   |# class Logger\n   |   |       |# class Message\n   |   |       |# class Action\n   |   |- Quoter.boo\n   |   |   |# class Quoter\n   |   |       |# class Quote\n   |   |- RawLogger.boo\n   |   |   |# class RawLogger\n   |   |- UrlGenerator.boo\n   |   |   |# class UrlGenerator\n   |   |       |# class Engine\n   |   |- UserTracker.boo\n   |   |   |# class UserTracker\n   |   |       |# class User\n   |   |- VersionCommand.boo\n   |   |   |# class VersionCommand\n   |   |- UrlTracker.boo\n   |       |# class UrlTracker\n   |           |# class Url\n   |- ActionEventArgs.boo\n   |   |# enum ActionType\n   |   |# class ActionEventArgs\n   |- DebugLogger.boo\n   |   |# enum LogImportance\n   |   |# class DebugLogger\n   |- Goomba.boo\n   |   |# class Goomba\n   |   |! Main Body (This will be executed when Goomba.exe is run)\n   |- GoombaPreferences.boo\n   |   |# class GoombaPreferences\n   |- IPlugin.boo\n   |   |# interface IPlugin\n   |- MessageEventArgs.boo\n   |   |# enum MessageType\n   |   |# class MessageEventArgs\n   |- Sender.boo\n       |# enum SenderType\n       |# class Sender  Which I have set up to create the assemblies  Goomba.exe ,  Goomba.Data.dll ,  Goomba.Configuration.dll , as well as one assembly per plugin.  You may have noticed a few important things:   For every directory, it represents a different namespace, with the same name as the directory itself.  Each  .boo  file has at most one class in it. That class will have the  same exact  name as the  .boo  file.  The \"Main Body\" section is below the  class  Goomba definition. Any inline executable code must be at the bottom of a file in the assembly.  Enums  come before classes. This is merely a coding practice that is not required, but recommended. If an  enum  is larger than 15 values, place it in its own file.", 
            "title": "On the Project-level"
        }, 
        {
            "location": "/Primer/Structure-of-a-project/#on-the-file-level", 
            "text": "Files must be defined in this order:   Module docstring  Namespace declaration  Import statements  Enums/Classes/Structs/Interfaces  Functions  Main code executed when script is run  Assembly attributes    Hint  One class per file. If you have more than one class per file, split it up. If you have a class inside another class, this is acceptable, as it still has one flat class per file.", 
            "title": "On the File-level"
        }, 
        {
            "location": "/Primer/Documentation/", 
            "text": "Note\n\n\nA communicable material used to explain some attributes of an object, system or procedure.\n\n\n\n\nI've saved the most important for last, as documentation is itself, just as important as the code which it describes.\n\n\nWhen documenting your code, be sure to remember:\n\n\n\n\nAll your documents should be in English.\n\n\nUse full sentences.\n\n\nAvoid spelling/grammar mistakes.\n\n\nUse present tense.\n\n\n\n\nDocumentation is placed in tripled double-quoted strings right below what you are documenting.\n\n\nDocumentation with Summary\n\n\ndef Hello():\n\nSays \nhello\n to the world.\n\n    print \nHello, World!\n\n\nHello()\n\n\n\n\nThat \"docstring\" is the least you can do to document your code. It gave a simple summary.\n\n\nIf your docstring spans more than one line, then the quotes should go on their own lines.\n\n\nYou may have noticed that 'Says \"hello\" to the world.' is not a full sentence. For the first sentence in a summary, you can imply \"This member\".\n\n\nParameters should also be documented.\n\n\nParameters\n\n\ndef Hello(name as string):\n\n\nSay \nhello\n to the given name.\nParam name: The name to say hello to.\n\n\n    print \nHello, $name!\n\n\nHello(\nHarry\n)\n\n\n\n\nTo read it to yourself, it goes as such: 'Say \"hello\" to the given name. Parameter name is defined as the name to say hello to.'\n\n\nThis keeps in line with using full sentences. If describing the parameter takes more than one line, you should move it all to a new line and indent.\n\n\nLong Parameter\n\n\ndef Hello(name as string):\n\n\nSay \nhello\n to the given name.\nParam name:\n    The name to say hello to.\n    It might do other things as well.\n\n\n    print \nHello, $name!\n\n\n\n\n\nThe same goes with any block.\n\n\nHere is a list of all the tags that can be used:\n\n\n\n\n\n\n Tag \n\n\n Description \n\n\n\n\n\n\n No tag \n\n\n A summary of the member. \n\n\n\n\n\n\n \nParam\n \nname\n:\n \ndescription\n \n\n\n This specifies the parameter \nname\n of the method. \n\n\n\n\n\n\n \nReturns:\n \ndescription\n \n\n\n This describes what the method returns. \n\n\n\n\n\n\n \nRemarks:\n \ntext\n \n\n\n This provides descriptive text about the member. \n\n\n\n\n\n\n \nRaises\n \nexception\n:\n \ndescription\n \n\n\n Gives a reason why an \nException\n is raised. \n\n\n\n\n\n\n \nExample:\n \nshort_description\n:\n \ncode_block\n \n\n\n Provides an example. \n\n\n\n\n\n\n \nInclude\n \nfilename\n:\n \ntagpath\n[@\nname\n=\"\nid\n\"]\n \n\n\n Includes an excerpt from another file. \n\n\n\n\n\n\n \nPermission\n \npermission\n:\n \ndescription\n \n\n\n Describe a required Permission. \n\n\n\n\n\n\n \nSee Also:\n \nreference\n \n\n\n Lets you specify the reference that you might want to appear in a See Also section. \n\n\n\n\n\n\n\nAnd a list of inline tags:\n\n\n\n\n\n\n Tag \n\n\n Description \n\n\n\n\n\n\n \n*\n \nitem\n \n\n\n*\n \nitem\n \n\n\n*\n \nitem\n \n\n\n Bullet list \n\n\n\n\n\n\n \n#\n \nitem\n \n\n\n#\n \nitem\n \n\n\n#\n \nitem\n \n\n\n Numbered List \n\n\n\n\n\n\n \nreference\n \n\n\n Provides an inline link to a reference. e.g. \nint\n or \nstring\n would link. \n\n\n\n\n\n\n \n[\nparam_reference\n]\n \n\n\n References to a parameter of the method. \n\n\n\n\n\n\n\nHere's some examples of proper documentation:\n\n\nDocumentation example\n\n\nimport System\n\nclass MyClass:\n\nPerforms specific duties.\n\n    def constructor():\n    \nInitializes an instance of \nMyClass\n\n        _rand = Random()\n\n    def Commit():\n    \nCommits an action.\n\n        pass\n\n    def CalculateDouble(i as int) as int:\n    \n\n    Returns double the value of [i].\n    Parameter i: An \nint\n to be doubled.\n    Returns: Double the value of [i].\n    \n\n        return i * 2\n\n    def CauseError():\n    \n\n    Causes an error.\n    Remarks: This method has not been implemented.\n    Raises NotImplementedException: This has not been implemented yet.\n    \n\n        return NotImplementedException(\nCauseError() is not implemented\n)\n\n    def DoSomething() as int:\n    \n\n    Returns a number.\n    Example: Here is a short example:\n        print DoSomething()\n    Returns: An \nint\n.\n    See Also: MakeChaos()\n    \n\n        return 0\n\n    def MakeChaos():\n    \n\n    Creates Chaos.\n    Include file.xml: Foo/Bar[@id=\nentropy\n]\n    Permission Security.PermissionSet: Everyone can access this method.\n    \n\n        print \nI am making chaos: $(_rand.Next(100))\n\n\n    def Execute():\n    \n\n    Executes the protocol.\n    Does one of two things,\n    # Gets a sunbath.\n    # Doesn't get a sunbath.\n    \n\n        if _rand.Next(2) == 0:\n            print \nI sunbathe.\n\n        else:\n            print \nI decide not to sunbathe.\n\n\n    def Calculate():\n    \n\n    Does these things, in no particular order,\n    * Says \nHello\n\n    * Looks at you\n    * Says \nGoodbye\n\n    \n\n        thingsToDo = [\nI look at you.\n, 'I say \nHello.\n', 'I say \nGoodbye.\n']\n        while len(thingsToDo) \n 0:\n            num = _rand.Next(len(thingsToDo))\n            print thingsToDo[num]\n            thingsToDo.RemoveAt(num)\n\n    [Property(Name)]\n    _name as string\n    \nA name\n // documents the property, not the field\n\n    Age as int:\n    \nAn age\n\n        get:\n            return _rand.Next(8) + 18\n\n    _age as int\n\n    _rand as Random\n\n\n\n\nThis should give you a good view on how to document your code.\nI think Dick Brandon said it best:\n\n\n\n\nQuote\n\n\nDocumentation is like sex: when it is good, it is very, very good; and when it is bad, it is better than nothing.", 
            "title": "Documentation"
        }, 
        {
            "location": "/Primer/Useful-Links/", 
            "text": "Boo\n\n\nDownload Boo\n\n\nMSDN Search\n - Very handy if you want to look up something in the standard library.\n\n\nMono Docs\n - Nice source of information as an alternative to MSDN, or if you work on Mono or Gtk specific projects.\n\n\nGoogle\n - Has a lot of information within its reach. Searching prefixed with \".NET Framework\" or \"C#\" usually will turn up what you need.\n\n\nNAnt\n - A free build tool for .NET", 
            "title": "Useful Links"
        }, 
        {
            "location": "/Guide/Structure-of-a-Boo-Script/", 
            "text": "Boo scripts have a set structure you need to follow to avoid errors when compiling. All of the items are optional, but order of the items is not:\n\n\nThe structure is like:\n\n\n\n\nmodule docstring\n\n\nnamespace declaration\n\n\nimport statements\n\n\nmodule members: class/enum/def declarations\n\n\nmain code executed when script is run\n\n\nassembly attributes\n\n\n\n\nFor example:\n\n\nmodule docstring\n\n\nnamespace My.NameSpace #optional namespace declaration\n\nimport Assembly.Reference #import statements\n\n#followed by the Members of this module (classes, methods, etc.)\nclass MyClass:\n    pass\n\ndef domyfunction(it):\n    print(it)\n\n#start \nmain\n section that is executed when script is run\nx as int\nx = 3\ndomyfunction(x)\n\n#optional assembly attribute declarations used when compiling\n[assembly: AssemblyTitle('foo')]\n[assembly: AssemblyDescription('bar')]\n\n\n\n\nThere is one issue with the above structure, however. What if you are creating a library (dll), and you want to have \"global\" properties or fields? Also, what if you want to do some things when your dll is loaded by another application?\n\n\nExample use:\n\n\nimport MyLibrary\nprint (Version)\ndoit()\n\n\n\n\nNow in Boo, you can do this by specifying a \"global\" class for your module. You tell the Boo compiler to use your class as the global, module-wide class by adding a [Module] attribute:\n\n\n[Module]\nclass MainClass:\n    public static Version as string\n\n    static def constructor():\n        Version = \n0.1\n\n\ndef doit():\n    #you can refer to \nglobals\n from within your library, too:\n    print(\nThis library's version is: \n+MainClass.Version)\n\n\n\n\nAlso in Boo you can define which method the compiler should use as the main entry point method. This is useful for example when you want to add an attribute (like STAThread) to the main method. This main method can be anywhere in your boo script, or you can put it inside your main module class if you want to combine both of these techniques.\n\n\n[STAThread]\ndef Main(argv as (string)):\n    ...main entry point", 
            "title": "Structure of a Boo Script"
        }, 
        {
            "location": "/Guide/Import/", 
            "text": "import TARGET (from ASSEMBLY)? (as ALIAS)?\n\n\n\n\nThe import construct makes all the members of the imported target available to the current module. So instead of writing:\n\n\nSystem.Console.WriteLine(\nand now for something completely different... \n)\nSystem.Console.WriteLine(\nimport!\n)\n\n\n\n\none can write:\n\n\nimport System\n\nConsole.WriteLine(\nanfscd...\n)\nConsole.WriteLine(\nimport!\n)\n\n\n\n\nThe target can be either a namespace or a type. When it's a type, all the type's static members can be referenced directly by name. So the previous example could be simplified even further:\n\n\n\nimport System.Console\n\nWriteLine(\nanfscd...\n)\nWriteLine(\nimport!\n)\n\n\n\n\nThe from clause can be used to specify an additional assembly reference as well as to disambiguate namespaces. When using a Namespace that is not defined in an assembly with the name of the Namespace, you should use from:\n\n\n\nimport Some.Namespace from Weird.Assembly.Name\nimport Gtk from \ngtk-sharp\n\n\n\n\n\nfrom also accepts a quoted string as argument for weird named assemblies:\n\n\nimport Gtk from \ngtk-sharp\n\n\nApplication.Init()\n\n\n\n\nAnd speaking of assembly references, the boo compiler automatically add 4 assembly references before compiling any code: Boo, Boo.Lang.Compiler, (ms)corlib and System.", 
            "title": "Import"
        }, 
        {
            "location": "/Guide/Comments/", 
            "text": "Single Line Comments\n\n\nEverything that comes after a hash character (#) or a double backslace (//) is ignored until the end of the line.\n\n\n# this is a comment\n// This is also a comment\nprint(\nHello, world!\n) // A comment can start anywhere in the line\n\n\n\n\nMultiline Comments\n\n\nMultiline comments in boo are delimited by the /\n and \n/ sequences. Just like in C. Unlike in C though, boo multiline comments are nestable.\n\n\n/* this is a comment */\n/* this\ncomment\nspans mutiple\nline */\n\n/* this is a /*\n                 nested comment */\n    comment */\n\n\n\n\n\n\nWarning\n\n\nNested comments must be properly nested, however, or the parser will complain.\n\n\n\n\n/* this is a /* syntax error */", 
            "title": "Comments"
        }, 
        {
            "location": "/Guide/Builtin-Functions/", 
            "text": "Here is a summary of boo's built-in functions. The actual source code underlying these functions is in \nBoo/Lang/Builtins.cs\n.\n\n\narray\n\n\narray is a function used to create empty arrays or convert IEnumerable and ICollection objects to arrays. See \nLists And Arrays\n for more info.\n\n\narray(object as IEnumerable)\n:\n\n\nConverts an IEnumerable object to a non-specific (type of System.Object) array.\n\n\narray(type as Type, collection as ICollection)\n:\n\n\nConverts any object that implements ICollection to an array of Type.\n\n\narray(type as Type, enumerable as IEnumerable)\n:\n\n\nConverts any object that impelements IEnumerable to an array of Type.\n\n\narray(type as Type, size as int)\n:\n\n\nCreates an empty array of the specified size.\n\n\nBooVersion\n\n\nBooVersion is a builtin property that returns the current version of boo that is running. It returns a System.Version class. See \nGetting Boo Version\n for more info.\n\n\nenumerate\n\n\nenumerate(enumerable as object) as EnumerateEnumerator\n:\n\n\nenumerate() is useful when you want to keep a running count while looping through items using a for loop:\n\n\nmylist = [\na\n, \nb\n, \nc\n]\nfor i as int, obj in enumerate(mylist):\n      print i, \n:\n, obj\n\n\n\n\ngets\n\n\nReturns a string of input that originates from Console.ReadLine() - AKA, \"Standard Input.\"\n\n\ngets()\n:\n\n\nThe equivilent of Console.ReadLine(). See also prompt() below.\n\n\niterator\n\n\niterator(enumerable as object) as IEnumerable\n:\n\n\nUsually not necessary, this builtin returns any Enumerator it can find in the object passed. For loops do this for you.\n\n\njoin\n\n\nAlways returning a string, join is a function that will walk through an enumerable object and put all of those elements into one string.\n\n\njoin(enumerable as IEnumerable)\n:\n\n\nJoins all of the elements in enumerable into one string, using a single space (ASCII Code: 32) between elements.\n\n\njoin(enumerable as IEnumerable, seperator as Char)\n:\n\n\nThe same as join(enumerable as IEnumerable), except that seperator defines what character seperates each element in enumerable.\n\n\nmap\n\n\nmap returns an enumerable object that applies a specific function to each element in an enumerable object.\n\n\nmap(enumerable as IEnumerable, function as ICallable)\n:\n\n\nTaking an enumerable object such as a list or a collection, it returns an IEnumerable object that applies \"function\" to each element in the array.\n\n\nExamples:\n\n\ndef HardRock(item):\n    return \n$item totally rocks out, man!\n\n\nwyclefSongs = (\nTwo wrongs\n, \nDirty Dancing\n)\n\nx = map(wyclefSongs, HardRock)\nfor y in x:\n    print y\n\n//another example using a multiline anonymous closure:\nnewlist = map([1,2,3,4,5,6]) def (x as int):\n    return x*x*x\n\n\n\n\nOutput:\n\n\nTwo wrongs totally rocks out, man!\nDirty Dancing totally rocks out, man!\n\n\n\n\nmatrix\n\n\nSee \nMultidimensional Arrays\n for more info, but here is a basic example:\n\n\nmatrix(elementType as Type, length of first dimension as int, length of second dimension as int)\n:\n\n\nCreates a multidimensional array of type elementType with the specifications of length.\n\n\nExamples\n\n\nfoo = matrix(int, 2, 2)\nfoo[0, 0] = 0\nfoo[0, 1] = 1\nfoo[1, 0] = 2\nfoo[1, 1] = 3\n\nprint join(foo) //prints \n0, 1, 2, 3\n\n/* Looks like,\n[0, 1\n 2, 3]\n*/\n\n\n\n\nprint\n\n\nPrints an object to Standard Out. The equivilent of Console.WriteLine\n\n\nprint(object as Object)\n:\n\n\nThe equivilent of Console.WriteLine()\n\n\nprompt\n\n\nPrompts the user for information.\n\n\nprompt(query as string)\n:\n\n\nPrints query to standard output, then waits for a user to 'respond.' Returns a string containing what the user has typed.\n\n\nrange\n\n\nA mysterious, somewhat exciting function that returns an enumerable object containing a list of elements such as 1 to 10 or 0 to 5 or 77 to 6.\n\n\nrange(max as int)\n:\n\n\nReturns an IEnumerable object that contains elements from 0 to max - 1.\n\n\n#This prints 0 through 9:\nfor i in range(10):\n    print i\n\n\n\n\nrange(begin as int, end as int)\n:\n\n\nReturns an IEnumerable object that contains elements from begin to end - 1.\n\n\nrange(begin as int, end as int, step as int)\n:\n\n\nReturns an IEnumerable object that contains all of the elements from begin to end - 1 that match the interval of step.\n\n\nExample:\n\n\nfor i in range(0, 10, 2):\n    print i\n\n\n\n\nOutput:\n\n\n0\n2\n4\n6\n8\n\n\n\n\nreversed\n\n\nreversed(enumerable as object) as IEnumerable\n:\n\n\nReturns items in an enumerable in reverse order.\n\n\nshell\n\n\nshell is used for invoking processes and inspecting their output.\n\n\nshell(filename as string, arguments as string)\n:\n\n\nInvoke an application (filename) with the arguments (arguments) specified. Returns a string containing the program's output to Standard Out (aka, the console)\n\n\nshellm(filename as string, arguments as (string) )\n:\n\n\nInvoke an application (filename) with an array of arguments (arguments); returns a string containing program's output.\n\n\nshellp(filename as string, arguments as string)\n:\n\n\nStarts a process specified by filename with the arguments provided and returns a Process object representing the newly born process.\n\n\nzip\n\n\nzip returns an IEnumerable object that interleaves the two arrays.\n\n\nzip(first as IEnumerable, second as IEnumerable)\n:\n\n\nzip will return an IEnumerable object, wherein each element of the IEnumerable object will be a one dimensional array containing two elements; the first element will be an element located in \"firstNames\" and the second will be an element located in \"lastNames.\"\n\n\nExample:\n\n\nfirstNames = (\nCharles\n, \nJoe\n, \nP\n)\nlastNames = (\nWhittaker\n, \nManson\n, \nDiddy\n)\n\nx = zip(firstNames, lastNames)\nfor y in x:\n    print join(y)\n        //print y[0], y[1]\n\n\n\n\nOutput:\n\n\nCharles Whittaker\nJoe Manson\nP Diddy", 
            "title": "Builtin Functions"
        }, 
        {
            "location": "/Guide/Developing-in-Net/", 
            "text": "These are pages with general help on developing applications for .NET and Mono, and other topics not specific to boo itself but useful for a boo developer.\n\n\nGeneral Info about .NET and Mono\n\n\n.NET is Microsoft's application framework and runtime engine. Most people using Windows XP have .NET version 1.1, but the 2.0 version was released in the fall of 2005. Boo now supports .NET 4.0.\n\n\nThere is also an open source clone of .NET called \nMono\n, that runs on Linux, Mac OS X, and Windows. It is derived from the open \nCommon Language Infrastructure\n (CLI) specification used by .NET.\n\n\nSee also these resources:\n\n\n\n\nThe \n.NET Development\n page at MSDN\n\n\nInside the .NET Framework\n\n\n.NET Class Library\n\n\nThe Code Project\n - samples and tutorials\n\n\n\n\nBelow are some resources for developing .NET/Mono applications (primarily the open source and free resources), as well as tutorials.\n\n\nIDEs - Integrated Development Environments\n\n\n\n\nSharpDevelop\n - free, open source, includes a forms designer/GUI builder. Windows only. SharpDevelop supports boo fully.\n\n\nMonoDevelop \n- Works with Mono on Linux or Mac. Peter Johanson has created a boo add-in for MonoDevelop.\n\n\nNant \n- an XML-based build tool based on Java's ant build tool. Used to build boo itself.\n\n\nVisual Studio 2010 (and there is a free Express version of VS 2010 too). The standard commercial IDE used on Windows. People are interested in creating a boo plugin for VS.\n\n\nMonolipse \nThere is a boo addin for Eclipse called monolipse. monolipse originated as another project named booclipse but has been expanded to support other EMCA languages such as C#.\n\n\nSciBoo \n- by Steve Donovan, a ScintillaNET based editor.\n\n\nSmulton \n- by Peter Borg. A Mac OS X text editor. An \nadd-in\n for Boo support is authored by Grant Morgan from the Unity3d.com team. With the Smultron command window you can automatically execute your boo code without leaving the editor.\n\n\n\n\nWeb Development\n\n\nSee the \nASP.NET\n page and tutorials.\n\n\nASP.NET is the standard, but see also:\n\n \nCastle \nand its MonoRail and Brail projects\n\n \nMaverick.NET\n\n\nDeveloping Desktop GUI Applications\n\n\nWindows.Form\ns\n\n\nThe standard Windows API, but you can call it from Linux as well, using Mono's Managed.Windows.Forms project. Here are some code snippets and tutorials on using Windows.Forms:\n\n\n\n\nWindows Forms Quickstart tutorial\n - tutorials and code snippets for using every type of control\n\n\nCode for Windows Forms Controls\n - also has examples of using just about every control\n\n\nWindows Forms FAQ\n\n\nUsing .NET Windows Forms Controls\n - article going over basic usage of each of the main form controls\n\n\n\n\nThe easiest way to create windows forms with boo is to use SharpDevelop. It has a form designer with support for boo, if you use the new version. If you use an older version or another C# form designer, you can convert the C# generated code to boo automatically.\n\n\nGTK#\n\n\nGTK#\n is the GUI API used in the GNOME project for Linux, but you can use it on Windows and Mac OS X too, see these articles:\n\n We have a \ntutorial \non creating a sample GTK# application with the Glade GUI designer.\n\n \nCross platform GUI comes to .NET\n\n* \nHow to Write a Basic Gtk# Program with Mono\n\n\nGTK# on Windows\n\nThere are two versions of GTK# that run on Windows.\n\n One runs in .NET 1.1 (here is the \ninstaller\n)\n\n the other runs in Mono, and is included in the combined \nMono installer\n for Windows.\n\n\nNote though, to compile apps that use the GTK# runtime for .NET 1.1, you may need to download the \n.NET 1.1 SDK\n to get them to compile.\n\n\nAnother item now available on Windows is the [Gecko Runtime Engine (GRE)] (https://developer.mozilla.org/en/docs/GRE). This lets you embed the Mozilla browser engine in your GTK# app as a WebControl.\n\n\nSee also\n\nWX.NET and QT#\n\n\nDatabases\n\n\n\n\nADO.NET\n - the standard API for working with relational databases, see also \nDatabase Recipes\n and \nDatabase Design\n.\n\n\nMost relational database engines have interfaces to .NET/Mono, such as SQLite, MySQL, MS SQL Server, MS Access, Firebird...\n\n\nThe \nDatabase Recipes\n page also shows examples of non-SQL-based database engines such as db4o.\n\n\n\n\nMath / Statistics\n\n\n\n\ndnAnalytics\n\n\nMath.NET\n\n\nSharp3D.Math\n\n\n\n\nGraphics\n\n\n\n\nGenerate PDF reports\n\n\n\n\n\n\nSharpPDF\n\n\n\n\n\n\n\n\n\n\nReport.NET\n\n\n\n\n\n\nStructured Graphics\n\n\n\n\n\n\nPiccolo.NET\n\n\n\n\n\n\n\n\n\n\nSVG#\n\n\n\n\n\n\n\n\n\n\nDiagram.NET\n\n\n\n\n\n\nPlotting / Charts\n\n\n\n\n\n\nNPlot\n\n\n\n\n\n\n\n\n\n\nZedGraph\n\n\n\n\n\n\nGraph Libs / Graph Drawing\n\n\n\n\n\n\nQuickGraph\n\n\n\n\n\n\n\n\n\n\nNetron\n\n\n\n\n\n\n\n\n\n\nDiaCanvas#\n\n\n\n\n\n\n\n\n3D, Game Development\n\n\n\n\nFor OpenGL and SDL, use:\n\n\n\n\n\n\nTao Framework\n - for examples see \nOpenGL 3D Samples\n.\n\n\n\n\n\n\n\n\n\n\nSDL.NET\n\n\n\n\n\n\n\n\nFor DirectX, you need to download the DirectX SDK from Microsoft and use the Managed DirectX API. See:\n\n\n\n\n\n\n\n\nManaged DirectX Resources\n\n\n\n\n\n\n\n\n\n\nManaged World\n\n\n\n\n\n\n\n\nGame Engines\n\n\n\n\n\n\n\n\nRealmForge \n- OpenGL and DirectX can be used interchangeably\n\n\n\n\n\n\n\n\n\n\nIrrlicht \n- has .NET bindings, can also use OpenGl or DirectX\n\n\n\n\n\n\n\n\n\n\nOvorp \n- 2D game engine\n\n\n\n\n\n\n\n\nPhysics\n\n\n\n\n\n\n\n\nODE.NET\n\n\n\n\n\n\n\n\nPlease add any game programming tips or samples you have to this site or the \nboo page\n at the game programming wiki.\n\n\nOthers\n\n\n\n\nIndyProject \n- networking libs for doing ftp, soap, http, smtp, pop, nntp, etc.\n\n\nNetspell\n\n\n\n\n\n\nSee also: \nGnomeFiles \nfor some Mono apps and libs, \nCSharp-Source\n for open source .NET libraries and apps, and \nCodeProject \nfor many useful .NET tutorials and code samples.", 
            "title": "Developing in Net"
        }, 
        {
            "location": "/Guide/String-operations/", 
            "text": "String Formatting\n\n\nSee \nString Interpolation\n.  Here's a quick example:\n\n\nfirstname = \nFirst\n\nlastname = \nLast\n\n\nprint \nYour name is $firstname $lastname.\n\n\nprint \nNow is $(date.Now).\n\n\n\n\n\nBacktick quoted strings\n\n\nWhen we want to provide a string literal in its verbatim form we can use backtick \"`\" characters to quote the string, disabling any interpolation or formatting in it.\n\n\nprint `this string is not $interpolated`\n# output: this string is not $interpolated\n\n\n\n\nAdditionally backtick quoted strings can expand multiple lines while retaining the actual whitespace in the source file. This makes them very useful for DSLs that want to process the literals:\n\n\neval `\n  foo = 10\n  print foo\n`\n\n\n\n\nToString() Method\n\n\nTo convert a class or a type to a string, call the ToString() method. Or if you are writing your own class you can define your own ToString() method to control how your class is printed.\n\n\nConverting from int to string and Back\n\n\n//string to int\nval as int\nval = int.Parse(\n1000\n)\nprint val\n\n//string to double\npi as double\npi = double.Parse(\n3.14\n)\nprint pi\n\n//int or double to string\ns as string\ns = val.ToString()\nprint s\n\n//multiple values to one formatted string\nastr as string\nastr = \n$val and $pi\n\nprint astr\n\n//date parsing\nd as date\nd = date.Parse(\n12/03/04\n)\n\n\n\n\nParsing and Converting Other Types\n\n\nSee \nthis tutorial\n on the Parse and Convert techniques, as well as date parsing.\n\n\nString Comparisons\n\n\n//regular comparison\nif \nasdf\n == \nASDF\n:\n    print \nasdf == ASDF\n\nelse:\n    print \nasdf != ASDF\n\n\n//case-insensitive comparison\nif string.Compare(\nasdf\n, \nASDF\n, true) == 0:\n    print \ncase-insensitively the same\n\n\ns = \nAnother String\n\n\nif s.StartsWith(\nAnother\n):\n    print \nstarts with 'Another'\n\nif s.EndsWith(\nString\n):\n    print \nends with 'String'\n\n\nprint \n'String' starts at:\n, s.IndexOf(\nString\n)\n\nprint \nThe last t is at:\n, s.LastIndexOf(\nt\n)\n\n//use built-in regex support to split a string\nwords = @/ /.Split(s) //split on whitespace (could use \\s)\nfor word in words:\n    print word\n\n\n\n\nSee the .NET reference on \nBasic String Operations\n for more information on string comparisons.", 
            "title": "String operations"
        }, 
        {
            "location": "/Guide/Triple-Quoted-Strings/", 
            "text": "Triple quoted strings in Boo are used to preserve spacing and linebreaks without a thick slathering of \\n's all over your precious code.\n\n\nIt is good for visually representing XML, for instance:\n\n\nxml = \n\n\nxml\n\n     \nrandomElement\n\n     \n/randomElement\n\n\n/xml\n\n\n\n\n\n\n\nIt is also most excellent for formatting console output:\n\n\nname = prompt(\nName: \n)\nage = prompt(\nAge: \n)\nsex = prompt(\nSex: \n)\n\nprint \n\n\nHello, ${name}!\n\nMy name is Hal, and I will be your Operating System today.\n\nMy sensors indicate that you are a ${age} year old ${sex}\n\nIf you need any assistance navigating this user interface, please ask.\n\n...\n\nHumans are so fragile...", 
            "title": "Triple Quoted Strings"
        }, 
        {
            "location": "/Guide/Regular-Expressions/", 
            "text": "Boo has built-in support for regular expression literals.\n\n\nYou surround the regular expression with \n/ /\n or \n@/ /\n for more complex expressions\nthat contain whitespace. Boo even has an \n=~\n operator like Perl.\n\n\nHere are some samples of using regular expressions in boo:\n\n\n//pattern matching using perl's match operator (=~)\nsamplestring = \nHere is foo\n\nif samplestring =~ /foo/:\n       print \nit's a match\n\n\n//sample regex object\nre = /foo(bar)/\nprint re.GetType() //-\n System.Text.RegularExpressions.Regex\n\n//split a line on spaces:\nwords = @/ /.Split(samplestring)  //you can also use \\s for any type of whitespace\nprint join(words, \n,\n)\n\n//similar example with unpacking\ns = \nFirst Last\n\nfirst, last = @/ /.Split(s)\n\n//another way to do matching without =~\nm = /abc/.Match(\n123abc456\n)\nif m.Success:\n      print \nFound match at position:\n, m.Index\n   print \nMatched text:\n, m.ToString()\n\n//more complex example with named groups\ns = \n\nJoe Jackson\n131 W. 5th Street\nNew York, NY  10023\n\n\n\nr = /(?\n=\\n)\\s*(?\ncity\n[^\\n]+)\\s*,\\s*(?\nstate\n\\w+)\\s+(?\nzip\n\\d{5}(-\\d{4})?).*$/.Match(s)\n\nprint r.Groups[\ncity\n]\nprint r.Groups[\nstate\n]\nprint r.Groups[\nzip\n]\n\n//just for reference, the match operator (=~) works with regular strings, too:\nif samplestring =~ \nfoo\n:\n        print \nit matches\n\n\n//the \nnot match\n operator (!~) has not been implemented yet, but you\n//can simply prefix the expression with \nnot\n:\nif not samplestring =~ /badfoo/:\n       print \nno match\n\n\n\n\n\nSpecifying regex options\n\n\nOne limitation of using built-in support for regular expressions is that you can't use non-standard \nregex options\n like regex compiled.\n\n\nActually there is a way to use the ignore case option. Add a (?i) to the beginnning of your regex pattern like so:\n\n\npattern = /(?i)google/\nprint \ngoogle\n =~ pattern\nprint \nGoogle\n =~ pattern\n\n\n\n\nBut in other cases you may want to just use the .NET Regex class explicitly:\n\n\nimport System.Text.RegularExpressions\n\nsamplestring = \nHere is foo\n\nre = Regex(\nFOO\n, RegexOptions.IgnoreCase | RegexOptions.Compiled)\n\n//one way:\nif samplestring =~ re:\n   print \nwe matched\n\n\n//another using Match\nif re.IsMatch(samplestring):\n print \nwe matched\n\n\n\n\n\nRegex Replace method\n\n\nThis would be an equivalent to using perl's switch/replace statement: s/foo/bar/g.\n\n\nimport System.Text.RegularExpressions\n\ntext = \nfour score and seven years ago\n\nprint text\n\n//replace each word with \nX\n\nt2 = /\\w+/.Replace(text, \nX\n)\nprint t2 //-\n X X X X X X\n\n//replace only the first occurence of a word with X,\n// starting after the 15th character:\nt3 = /\\w+/.Replace(text, \nX\n, 1, 15)\nprint t3 //-\n four score and X years ago\n\n//use a closure (or a regular method) to capitalize each word:\nt4 = /\\w+/.Replace(text) do (m as Match):\n    s = m.ToString()\n    if System.Char.IsLower(s[0]): //built-in char type will be added soon\n         return System.Char.ToUpper(s[0]) + s[1:]\n    return s\nprint t4 //-\n Four Score And Seven Years Ago\n\n\n//Back References are supported too! using the dollar sign\nphonenumber = \n5551234567\n\nphonenumber = /(\\d{3})(\\d{3})(\\d{4})/.Replace(phonenumber, \n($1) $2-$3\n)\nprint phonenumber //-\n (555) 123-4567\n\n\n\n\nregex primitive type\n\n\nAlso note, Boo has a built-in primitive type called \"regex\" (lowercase) that means the same thing as the .NET Regex class. So you can do for example:\n\n\nimport System.Text.RegularExpressions\n\nre = /foo(bar)/\n\nif re isa regex:\n    print \nre is a regular expression\n\n\n//or declare the type explicitly:\nre2 as regex = /foo(bar)/\nprint re2 isa regex\n\n//using the regex primitive constructor\n//(You'll need an import statement for RegexOptions)\nre3 = regex(\nFOO\n, RegexOptions.IgnoreCase | RegexOptions.Compiled)\nprint re3 isa regex\n\n\n\n\nSee also:\n\n\n\n\nUsing Regular Expressions in .NET\n\n\n.NET Framework Regular Expressions\n\n\nThe \nRegular Expression Library\n has hundreds of user-contributed regex samples.\n\n\ntxt2regex\n - command line to assist with constructing regular expressions", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/Guide/XML-Serialization/", 
            "text": "Here is an example based on the \nAdvanced Tutorial, Learning Boo Kung-Fu\n.\n\nNote, you have to compile this to an exe and then run it. It won't work in booi, because types in dynamically generated assemblies can't be serialized apparently.\n\n\nimport System.Xml from System.Xml\nimport System.Drawing from System.Drawing\nimport System.ComponentModel\nimport System.Xml.Serialization\nimport System.IO\nimport System\n\nclass Ninja:\n    [XmlAttribute(\nname\n)]\n    public Name as string\n    [XmlAttribute(\nstyle\n)]\n    public Style as string\n    [XmlAttribute(\nspeed\n)]\n    public Speed as int\n    [XmlAttribute(\nstrength\n)]\n    public Strength as int\n    [XmlAttribute(\nstamina\n)]\n    public Stamina as int\n\n    //problem serializing Colors: http://dotnetified.com/PermaLink.aspx?guid=E86B447E-AA95-49B6-909F-CDA36ACF481F\n    _color as Color\n    [XmlIgnore] //don't serialize this, we'll using StringColor instead\n    Color as Color:\n        get:\n            return _color\n        set:\n            _color = value\n\n    [XmlAttribute(\ncolor\n)]\n    [Browsable(false)] //so this property isn't used in an IDE\n    public StringColor as string:\n        get:\n            return ColorTranslator.ToHtml(_color)\n        set:\n            _color = ColorTranslator.FromHtml(value)\n\n    def ToString():\n        return \nYou see $Name, a ninja of the $Style with the stats $Strength/$Stamina/$Speed. He is $Color.\n\n\n\n\n//SERIALIZING FROM AN OBJECT TO XML:\n\nninja = Ninja(Name:\nHiyo\n, Style:\nDrunken Monkey\n,\n             Speed:77, Strength:88, Stamina:99,\n         StringColor:\n#880000\n)\n\nprint ninja\n\ns = XmlSerializer(typeof(Ninja))\n//convert to xml, print it out:\nprint \n\\nSERIALIZED EXAMPLE:\n\ns.Serialize(System.Console.Out, ninja)\nprint\n\n//to serialize to a file:\n//using out = StreamWriter(filename):\n//  s.Serialize(out, ninja)\n\n//to serialize to a string variable:\n//s as string\n//using out = StringWriter(s):\n//  s.Serialize(out, ninja)\n\n\n//DESERIALIZING FROM XML (with earlier example xml)\nxml = \n\n\nNinja color=\n#FF00FF\n name=\nJohn Kho Kawn\n style=\nCrazy Martial Arts\n strength=\n71\n speed = \n74\n stamina = \n65\n /\n\n\n\n\ns = XmlSerializer(typeof(Ninja))\nreader = StringReader( xml )\nnewninja as Ninja = s.Deserialize( reader )\nreader.Close()\nprint \n\\nDESERIALIZED EXAMPLE:\n\nprint newninja\n\n\n\n\nFor more info on XML Serialization in .NET and Mono, see these tutorials:\n\n\n\n\nIntroducing XML Serialization\n\n\nXML Serialization in C#\n\n\nXML Serialization in the .NET Framework\n\n\nHow to Serialize a Hashtable\n.\n    (you can serialize a hashtable using binary instead of xml, see below)\n\n\n\n\nNon-XML (Binary) Serialization\n\n\nThis is useful when you really just want to store and retrieve an object like a dictionary/hashtable, and you don't need to use XML.\n\n\nimport System.IO\nimport System.Runtime.Serialization.Formatters.Binary\n\ndef savetofile(obj, filename as string):\n    using stream = FileStream(filename, FileMode.OpenOrCreate ,FileAccess.Write):\n        savetostream(obj, stream)\n\ndef savetomemory(obj) as (byte):\n    using stream = MemoryStream():\n        savetostream(obj, stream)\n    return stream.GetBuffer()\n\ndef savetostream(obj, str as Stream): //see also CryptoStream\n    BinaryFormatter().Serialize(str, obj)\n\ndef loadfromfile(filename as string) as object:\n    using stream = FileStream(filename, FileMode.Open):\n        return loadfromstream(stream)\n\ndef loadfrommemory(buffer as (byte)) as object:\n    using stream = MemoryStream(buffer):\n        return loadfromstream(stream)\n\ndef loadfromstream(str as Stream) as object:\n    return BinaryFormatter().Deserialize(str)\n\nd = {\none\n: \nitem\n, \ntwo\n: \nanother item\n}\n\nprint \nmemory example...\n\nsaved = savetomemory(d)\nd2 as Hash = loadfrommemory(saved)\nfor key in d2.Keys:\n    print key, \n:\n, d2[key]\n\nprint \n\\nfile example...\n\nfilename = \nsaved-dict.dat\n\nsavetofile(d, filename)\nd3 as Hash = loadfromfile(filename)\nfor key in d3.Keys:\n    print key, \n:\n, d3[key]\n\n\n\n\nSee also:\n\n\n\n\nEncrypt a String for ideas about how you might serialize to a CryptoStream\n\n\nEncrypting data in network connections", 
            "title": "XML Serialization"
        }, 
        {
            "location": "/Guide/Generics/", 
            "text": "Declaring references to generic types\n\n\n\n\ninclude foo* for IEnumerable\n\n\n\n\nGeneric Method Invocation\n\n\nDefining Generic Types\n\n\n\n\nGeneric classes\n\n\nGeneric methods\n\n\n\n\nGeneric Constraints", 
            "title": "Generics"
        }, 
        {
            "location": "/Guide/Generics/#declaring-references-to-generic-types", 
            "text": "include foo* for IEnumerable", 
            "title": "Declaring references to generic types"
        }, 
        {
            "location": "/Guide/Generics/#generic-method-invocation", 
            "text": "", 
            "title": "Generic Method Invocation"
        }, 
        {
            "location": "/Guide/Generics/#defining-generic-types", 
            "text": "Generic classes  Generic methods", 
            "title": "Defining Generic Types"
        }, 
        {
            "location": "/Guide/Generics/#generic-constraints", 
            "text": "", 
            "title": "Generic Constraints"
        }, 
        {
            "location": "/Guide/Functions/", 
            "text": "Functions do not necessarily have to be created inside of classes in Boo.\n\n\nThis is valid code:\n\n\ndef doWickedAndNaughtyThings():\n     print \nI'm doing evil, wicked things to you.\n\n     print \nNo, don't call the police!\n\n     print \n...crap.\n\n\ndoWickedAndNaughtyThings()\n\n\n\n\nSo is this:\n\n\nclass Wife:\n    def MakeSandwich(toppings as (string) ):\n        for items in toppings:\n            GruelOverStove(items)\n        return Sandwich(toppings.Length)\n    def GruelOverStove(item):\n        print \n$(item)?! $(item)?! Who eats $(item)s?!\n\n\nclass Sandwich:\n    def constructor(length):\n        self.toppingCount= length\n    public toppingCount as int\n\n//Here's when things go procedural!\ndef EatSandwich(sammich):\n    print \nWhat, only $((sammich as Sandwich).toppingCount) toppings?!\n\n\nredhead = Wife()\nEatSandwich(redhead.MakeSandwich( (\nPickles\n, \nTurkey\n, \nMayonase\n, \nMustard\n, \nLettuce\n)  ) )\nprint \nDelicious! Now, where's the remote control?\n\n\n\n\n\nFunctions can also be placed inside other functions (these are called Closures or \"blocks\" in some languages).\n\n\ndef SpiceyMayo():\n    somethingNotDeservingOfAFunction = def():\n        print \nlol\n\n    somethingNotDeservingOfAFunction()\nSpiceyMayo()\n\n\n\n\nClosures are also handy in a variety of other situations.\n\n\nThere are also 3 special functions that can be used in classes. They are constructor, static constructor, and destructor. Each have no return type, modifiers, or attributes. Only the plain constructor takes parameters. Constructors are invoked when an instance is created. Static constructors are called only the first time the type is used. They should be used to initialize uninitialized static fields. Destructors perform commands when objects are freed.\n\n\nSee also:\n\n\nParameters\n, \nCallable Types\n, \nEvents\n\n\nClosures in Boo\n\n\nMartin Fowler yammering about Closures", 
            "title": "Functions"
        }, 
        {
            "location": "/Guide/Parameters/", 
            "text": "Parameters are the objects you can pass to \nFunctions\n, \nClosures\n, or \nCallable Types\n which handle \nEvents\n.\n\n\nA parameter is declared with a name, followed by \"as\", followed by the type: paramname as type. If there is no \"as type\", then the type is assumed to be type object.\n\n\nExamples\n\n\nMethod/Function example\n:\n\n\ndef mymethod(x as int, y as long):\n        ...\n\n\n\n\nClosure\n\n\nc = def(z):\n         print z\n\nobj = \na string\n\nc(obj)\n\n\n\n\nCallable Type + Event\n:\n\n\nimport System\n\nclass Sandwich:\n    event Eating as EatingEvent\n    callable EatingEvent(sammich as object, type as string)\n\n    def Eat():\n        Eating(self, \nTurkey sammich.\n)\n\nturkeyAndSwiss = Sandwich()\nturkeyAndSwiss.Eating += def(obj, sammich):\n    print \nYou're eating a $sammich! It must be good.\n\nturkeyAndSwiss.Eat()\n\n\n\n\nVariable Number of Parameters\n\n\nBoo allows you to call or declare methods that accept a variable (unknown) number of parameters.\n\n\nYou add an asterix (*) before the parameter name to signify that it holds multiple parameter values. If there is no 'as type', the type is assumed to be an array of objects: (object). You can declare the type as any array type. For example (int) if your method only accepts int parameters.\n\n\nHere is an example:\n\n\ndef mymethod(x as int, *rest):\n    print \nfirst arg:\n, x\n    for item in rest:\n        print \nextra param:\n, item\n    print\n\nmymethod(1, \na\n, \nb\n, \nc\n)\nmymethod(2, 3, 4, 5, 6, 7)\n\n\n\n\nSome boo builtins accept a variable number of parameters, like matrix() and ICallable.Call.\n\n\nByRef Parameters\n\n\nAdd a \"ref\" keyword before the parameter name to make a parameter be passed by reference instead of by value. This allows you to change a variable's value outside of the context where it is being used. Some examples:\n\n\nBasic byref example:\n\n\ndef dobyref(ref x as int):\n        x = 4\n\nx = 1\nprint x //--\n1\ndobyref(x)\nprint x //--\n4\n\n\n\n\nDllImport Example:\n\n\nWrapping a native method that takes a parameter by reference:\n\n\nimport System.Windows.Forms from System.Windows.Forms\nimport System.Drawing from System.Drawing\nimport System.Runtime.InteropServices\n\nclass ExtTextBox(TextBox):\n    //must be static\n    [DllImport(\nuser32\n)]\n    static def GetCaretPos(ref p as Point):\n        pass\n\n\nf = Form(Text: \nbyref test\n)\nt = ExtTextBox()\nf.Controls.Add(t)\n\nb = Button(Text: \nGetCaretPos\n)\nb.Click += do:\n    p = Point(0,0)\n    t.GetCaretPos(p)\n    MessageBox.Show(p.X.ToString())\nb.Location = Point(0,100)\nf.Controls.Add(b)\nApplication.Run(f)\n\n\n\n\nSee also \ntests/testcases/integration/callables/byref*.boo\n in the boo source distribution.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Guide/Loops/", 
            "text": "The for loop\n\n\nThe for loop syntax is:\n\n\nfor var in range:\n    // action\n\n\n\n\nwhere range can be any type of collection. Examples:\n\n\n// print numbers from 0 until 9\nfor i in range(0, 10):\n    print(i)\n\n\n\n\nit is equivalent to\n\n\n```C#\nfor (int i = 0; i \n 10; i++) \n    // print\n\n\n\nfrom C# or Java. You can also use with lists:\n\n```boo\nfor i in [300, 100, 23, 1, 55]:\n    print(i)\n\n\n\n\nitens = [2, 44, 56, 123, 98, 77, 1000]\nfor i in itens:\n    print (i)\n\n\n\n\nor arrays:\n\n\nfor i in (1, 4, 98, 399, 1000, 34, 199):\n    print (i)\n\n\n\n\nThe while loop\n\n\ni = 0\nwhile i \n 10:\n    print (i)\n    ++i\n\n\n\n\ni = 0\nwhile not(i \n 10):\n    print (i)\n    ++i\n\n\n\n\nIterating over collections:\n\n\nimport System.Collections\n\nclass Test:\n    def showAllValues(items as IList):\n        i = 0\n        itemsLen = len(items)\n        while i \n itemsLen and items[i].GetType() is not int:\n            print(\nBad, bad type: \n + items[i].GetType())\n            ++i\n\nclass Foo:\n    pass\n\nt = Test()\nf = Foo()\nt.showAllValues([\n1\n, t, f, 87, 31])", 
            "title": "Loops"
        }, 
        {
            "location": "/Guide/Exception-Handling/", 
            "text": "To handle exceptions in Boo you use the try - except block, and an optional ensure keyword, which may be used to have some code executed no matter the exception was raised or not. Just for a comparative, it is equivalent to try - catch - finally block from C# or Java.\n\n\nExecutes some code with exception handling:\n\n\ntry:\n    c = SomeClass()\n    c.DangerousAction(7)\nexcept e:\n    print(\nooops... We've got an error: \n + e)\n\n\n\n\nto raise exceptions, use the raise keyword:\n\n\nclass SomeClass:\n    def DangerousAction(i as int):\n        if i \n 10:\n            raise \nInvalid argument. It must not be less than 10\n\n\n        // Continue with the method\n\n\n\n\nYou can also handle specific Exception types using the form\n\n\nexcept var as type:\n\n\n\n\nas in \n\n\nclass MyInvalidArgumentException(System.Exception):\n    def constructor(argument, message):\n        super(\nError: \n + argument + \n is not valid. \n + message)\n\nclass SomeClass:\n    def DangerousAction(i as int):\n        if i \n 10:\n            raise MyInvalidArgumentException(i, \nIt must not be less than 10\n)\n\n        // Continue with the method\n\ntry:\n    c = SomeClass()\n    c.DangerousAction(2)\nexcept e as MyInvalidArgumentException:\n    print(\nError: \n + e)\nexcept e as AnotherTypeOfException:\n    // handle it\n\n\n\n\nUsing \nensure\n to do some clean-up, post-executing action etc...:\n\n\ntry:\n    c = SomeClass()\n    c.DangerousAction(33)\nexcept e:\n    print(\nooops... We've got an error: \n + e)\nensure:\n    print(\nThis code will always be executed.\n)", 
            "title": "Exception Handling"
        }, 
        {
            "location": "/Guide/Closures/", 
            "text": "Introduction\n\n\nMartin Fowler has a \ngood introduction to closures\n on his bliki.\n\n\nSyntax\n\n\nThere are two syntaxes for closures: a block based syntax with syntactically significant whitespace and a braces based that ignores whitespace.\n\n\nBlock based syntax\n\n\nimport System.Windows.Forms\nbutton = Button(Text: \nClick me\n)\nbutton.Click += def ():\n    print(\n$button was clicked!\n)\n    print(\nand yes, this is just like any other block...\n)\n\n\n\n\nBraces based\n\n\nimport System.Windows.Forms\nbutton1 = Button(Text: \nClick me\n, Click: { print \nclicked!\n })\nbutton2 = Button(Text: \nMe too!\n)\nbutton2.Click += { print \n$button2 was clicked!\n;\n    print \nwhitespace is ignored inside {}...\n;\n    print \nthat's why you need to use semicolons to include multiple statements...\n;\n    print \nbut please, don't write code like this just because you can :)\n\n}\n\n\n\n\nSemantics\n\n\nBoo closures have have full access (to read and write) to their enclosing lexical environment. For Instance:\n\n\na = 0 # declare a new variable\ngetter = { return a }\nsetter = { value | a = value }\n\nassert 0 == getter()\nsetter(42)\nassert 42 == getter()\nassert 42 == a\n\n\n\n\nThe best source of information right now are the test cases for closures in the \ntests/testcases/integration directory\n.\n\n\nClosures vs. Functions\n\n\nSee \nFunctions As Objects\n.\n\n\nSome things you can do with named functions that you cannot with closures include recursion and overloading:\n\n\nThis will not work because \"c\" is unknown from inside the closure:\n\n\nc = do(x as int):\n    print x\n    --x\n    c(x) if x \n 0\nc(5)\n\n\n\n\nso you can use a regular named function or else create a 2nd callable to hold the name:\n\n\ndef c(x as int):\n    print x\n    --x\n    c(x) if x \n 0\nc(5)\n\n//or:\n\nd as callable\nc = do(x as int):\n    print x\n    --x\n    d(x) if x \n 0\nd = c\nc(5)\n\n\n\n\nAnd you can use regular named functions to overload a method:\n\n\ndef doit(x as int):\n    print x\ndef doit(x as string):\n    print x\n\ndoit(3)\n\n\n\n\nSee Also\n\n\nFunctions\n, \nParameters\n, \nCallable Types\n, \nEvents", 
            "title": "Closures"
        }, 
        {
            "location": "/Guide/Generators/", 
            "text": "From time to time there is the need to represent closed sets such as customers in Brazil or open sets like the numbers in the Fibonacci series in a succinct and \nmemory conservative\n way. Enter generators.\n\n\nGenerators are language constructs capable of producing more than one value when used in an iteration context such as the for in loop.\n\n\nThe following generators are supported:\n\n\n\n\nGenerator Expressions\n\n\nGenerator Methods\n\n\nList Generators", 
            "title": "Generators"
        }, 
        {
            "location": "/Guide/Data-Types/", 
            "text": "Just a note that we could use some docs on:\n\n\n\n\nreference types\n\n\nvalue types (see also \nUser-defined value types aka structs\n and I assume a struct keyword will be added too)\nnull\n\n\n= vs. ==\n\n\n== vs. is\n\n\nis vs. isa\n\n\ntypeof\n\n\nx.GetType()\n\n\n\n\n== vs is vs isa\n\n\nThe \"==\" operation is deceptively simple. When a data structuer has overriden the \"Equals\" method, .NET/Boo checks the values of one data structure against another and returns true if they are identical or false if they are not. By default, .NET provides \"Equals\" overloads for most of the builtin data-types like int, float, decimal, string, and etc. Using \"==\", two seperate objects can be evaluated and it can be determined if, by value, they are equal or not.\n\n\nThe \"isa\" keyword determines if a variable is of a particular type. \"isa\" is useful in determining if a variable implements an interface, or derives from a common base class.\n\n\nThe \"is\" keyword serves a different, and somewhat more complex function. Sometimes you might want to go beyond the usual check of \"are these two variables of equal value?\" and see, \"are these two variables actually pointing to the same object?\" This is where \"is\" shines; it looks at the reference of two variables and determines if they both point to the same object!\n\n\nThis technique is normally used when you receive an object by poking a dictionary or invoking a method; if the identity of var1 and var2 is the same, then they are obviously equal--because they are the same object.\n\n\n\"==\" example:\n\n\n/*\nTrue,\nFalse,\nTrue!\n*/\na = 0\nb = 0\nc = 4\n\nprint a == b\nprint c == b\nprint a == 0\n\n\n\n\n\"isa\" example:\n\n\n/*\nPrints out...\nTrue,\nTrue,\nFalse!\n*/\nclass Food:\n    pass\n\nclass Sandwich(Food):\n    pass\n\nhamAndSwiss = Sandwich()\n\nprint hamAndSwiss isa Food\nprint hamAndSwiss isa Sandwich\nprint hamAndSwiss isa int\n\n\n\n\n\"is\" example:\n\n\n\n/*\nprints,\nTrue,\nFalse\n*/\nvar1 = \nhello, world!\n\nvar2 = var1\nvar3 = \nhey, carl!\n\nprint var1 is var2\nprint var1 is var3 //2 different objects pointed at!", 
            "title": "Data Types"
        }, 
        {
            "location": "/Guide/Type-Inference/", 
            "text": "Boo is a statically typed language.\n\n\nStatic typing is about the ability to type check a program for type correctness.\n\n\nStatic typing is about being able to deliver better runtime performance.\n\n\nStatic typing is not about putting the burden of declaring types on the programmer as most mainstream languages do.\n\n\nThe mechanism that frees the programmer from having to babysit the compiler is called \ntype inference.\n\n\nType inference means you don't have to worry about declaring types everywhere just to make the compiler happy. Type inference means you can be productive without giving up the safety net of the type system nor sacrificing performance.\n\n\nBoo's type inference kicks in for newly declared variables and fields, properties, arrays, for statement variables, overriden methods, method return types and generators.\n\n\nVariables\n\n\nAssignments can be used to introduce new variables in the current scope. The type for the new variable will be inferred from the expression on the right.\n\n\ns1 = \nfoo\n # declare new variable s1\ns2 = s1.Replace(\nf\n, \nb\n) # s1 is a string so Replace is cool\n\n\n\n\nOnly the first assignment to a variable is taken into account by the type inference mechanism.\nThe following program is illegal:\n\n\ns = \nI'm a string\n # s is bound with type string\ns = 42 # and although 42 is a really cool number s can only hold strings\n\n\n\n\nFields\n\n\nclass Customer:\n\n    _name = \n\n\n\n\n\nDeclare the new field _name and initialize it with an empty string. The type of the field will be string.\n\n\nProperties\n\n\nWhen a property does not declare a type it is inferred from its getter.\n\n\nclass BigBrain:\n      Answer:\n           get: return 42\n\n\n\n\nIn this case the type of the Answer property will be inferred as int.\n\n\nArrays\n\n\nThe type of an array is inferred as the \nleast generic type\n that could safely hold all of its enclosing elements.\n\n\na = (1, 2) # a is of type (int)\n\nb = (1L, 2) # b is of type (long)\n\nc = (\nfoo\n, 2) # c is of type (object)\n\n\n\n\nFor statement variables\n\n\nnames = (\n John \n,\n         \n Eric\n,\n         \n  Graham\n,\n         \nTerryG  \n,\n         \n TerryJ\n,\n         \n Michael\n)\n\nfor name in names:\n    # name is typed string since we are iterating a string array\n    print name.Trim()  # Trim is cool, name is a string\n\n\n\n\nThis works even when with \nunpacking\n:\n\n\na = ( (1, 2), (3, 4) )\n\nfor i, j in a:\n     print i+j  # + is cool since i and j are typed int\n\n\n\n\nOverridden methods\n\n\nWhen overriding a method, it is not necessary to declare its return type since it can be safely inferred from its super method.\n\n\nclass Customer:\n\n    override def ToString():\n         pass\n\n\n\n\nMethod return types\n\n\nThe return type of a method will the \nmost generic type\n among the types of the expressions used in return statements.\n\n\ndef spam():\n    return \nspam!\n\n\nprint spam()*3\n# multiply operator is cool since spam() is inferred to return a string\n# and strings can be multiplied by integer values\n\n\n\n\ndef ltuae(returnString as bool):\n    return \n42\n if returnString\n    return 42\n\n# ltuae is inferred to return object\nprint ltuae(false)*3  # ERROR! don't know the meaning of the * operator\n\n\n\n\nWhen a method does not declare a return type and includes no return statements it will be typed System.Void.\n\n\nGenerators\n\n\ng = i*2 for i in range(3)\n\n# g is inferred to generate ints\n\nfor i in g:\n    print i*2  # * operator is cool since i is inferred to be int\n\n# works with arrays too\na = array(g) # a is inferred to be (int) since g delivers ints\n\nprint a[0] + a[-1]  # int sum\n\n\n\n\nA Word of Caution About Interfaces\n\n\nWhen implementing interfaces it's important to explicitly declare the signature of a method, property or event. The compiler will look only for exact matches.\n\n\nIn the example below the class will be considered abstract since it does not provide an implementation with the correct signature:\n\n\nnamespace AllThroughTheDay\n\ninterface IMeMineIMeMineIMeMine:\n\n    def AllThroughTheNight(iMeMine, iMeMine2, iMeMine3 as int)\n\nclass EvenThoseTears(IMeMineIMeMineIMeMine):\n\n    def AllThroughTheNight(iMeMine, iMeMine2, iMeMine3):\n        pass\n\ne = EvenThoseTears()\n\n\n\n\nOk. So where do I have to declare types then?\n\n\nLet's say when.\n\n\n\n\nwhen the compiler as it exists today can't do it for you. Ex: parameter types, recursive and mutually recursive method/property/field definitions, return for abstract and interface methods, for untyped containers, properties with a only set defined\n\n\n\n\n    abstract def Method(param /* as object */, i as int) as string:\n        pass\n\n    def fat([required(value \n= 0)] value as int) as int:\n        return 1 if value \n 2\n        return value*fat(value-1)\n\n    for i as int in [1, 2, 3]: # list is not typed\n        print i*2\n\n\n\n\n\n\nwhen you don't want to express what the compiler thinks you do:\n\n\n\n\n    def foo() as object:  # I want the return type to be object not string\n        # a common scenario is interface implementation\n        return \na string\n\n\n    if bar:\n        a = 3 # a will be typed int\n    else:\n        a = \n42\n # uh, oh\n\n\n\n\n\n\nwhen you want to access a member not exposed by the type assigned to an expression:\n\n\n\n\n    f as System.IDisposable = foo()\n    f.Dispose()\n\n\n\n\n\n\nwhen you want to use \nDuck Typing\n:\n\n\n\n\n    def CreateInstance(progid):\n        type = System.Type.GetTypeFromProgID(progid)\n        return type()\n\n\n\n\n    ie as duck = CreateInstance(\nInternetExplorer.Application\n)\n    ie.Visible = true\n    ie.Navigate(\nhttp://boo.codehaus.org/Type+Inference\n)", 
            "title": "Type Inference"
        }, 
        {
            "location": "/Guide/Casting-Types/", 
            "text": "Type casting in boo works the same as in C# (see \nthis article\n). The only difference is that with explicit casts in boo you use the \"cast\" operator (see below).\n\n\nYou can try to cast one type to another type 3 ways: the \"as\" statement, an explicit cast, or an implicit cast. Here are examples:\n\n\n//The \nas\n cast silently returns null on failure\nyy = \n123\n as (int) //try to \nas\n cast a numeric string\n//It cannot, thus yy is null:\nif yy is null:\n    print \nyy is null\n\n\n//Explicit casts use the cast operator.\nnumb = 123.4\nzz = numb cast int\n\n//For implicit casts you declare the type of the left-hand variable,\n// and then try to assign an object to that variable:\naa as int = 123.4\n\n\n\n\nDon't use \"as\" cast for value types\n\n\nOne thing that might be misleading is that with the \"as\" cast that returns null if the cast fails, you cannot use that with value types (like ints, enums, etc.). Why? Because value types cannot be null (You can't have a null integer, for example. Integers have a default value of 0). The above example might be misleading because it uses the \"as\" cast for an array of ints. Arrays are passed by reference, not by value.\n\n\nSo in those cases when you have value types, you would use the explicit or implicit casts instead. This is how it works in C#, too.\n\n\nUsing \"isa\" for checking types before casting\n\n\nSometimes you may want to check an object's type first before attempting a cast. You can use the \"isa\" operator:\n\n\nfor item in [1, 2.0, \nthree\n]:\n    if item isa int:\n        print item, \nis an integer\n\n        print (item cast int + 3)\n    elif item isa double:\n        print item, \nis a double\n\n        print (item cast double / 0.33)\n    elif item isa string:\n        print item, \nis a string\n\n        //a string is not a value type so you can do\n        //the \nas\n cast if you want\n        print ((item as string).ToUpper())\n\n\n\n\nUse -ducky option or duck types for quick prototyping\n\n\nSee \nDuck Typing\n. Recent versions of boo add a -ducky option to the compiler that implicitly casts an object to type \"duck\" when the type cannot be inferred. What this does is hold off type resolution until runtime. This might be useful when you are just testing out some code.\n\n\nWith the -ducky option set, the above example could be coded more simply without the casts:\n\n\nfor item in [1, 2.0, \nthree\n]:\n    if item isa int:\n        print item + 3\n    elif item isa double:\n        print item / 0.33\n    elif item isa string:\n        print item.ToUpper()\n\n\n\n\nIt does make your code run slower though, so you'd want to later turn off the ducky option and fill in the appropriate casts as needed.", 
            "title": "Casting Types"
        }, 
        {
            "location": "/Guide/Duck-Typing/", 
            "text": "Duck Typing\n\n\nBoo is a statically typed language, like Java or C#. This means your boo applications will run about as fast as those coded in other statically typed languages for .NET or Mono. But using a statically typed language sometimes constrains you to an inflexible and verbose coding style, with the sometimes necessary type declarations (like \"x as int\", but this is not often necessary due to boo's \nType Inference\n) and sometimes necessary type casts (see \nCasting Types\n). Boo's support for \nType Inference\n and eventually generics help here, but...\n\n\nSometimes it is appropriate to give up the safety net provided by static typing. Maybe you just want to explore an API without worrying too much about method signatures or maybe you're creating code that talks to external components such as COM objects. Either way the choice should be yours not mine.\n\n\nAlong with the normal types like object, int, string...boo has a special type called \"duck\". The term is inspired by the ruby programming language's duck typing feature (\"If it walks like a duck and quacks like a duck, it must be a duck\").\n\n\nIf you declare an object as type duck or cast to type duck (or turn on the implicit duck typing option, see below), then boo will not try to resolve any methods or operations you call on that object at compile time. Instead it will convert those operations into methods that do not resolve until runtime. So at compile time it simply trusts that you know what you are doing (\"it walks like a duck so it must be a duck\"). This is easier to understand by looking at some examples.\n\n\nIllustrative Example: Static vs Duck Types\n\n\nThis code illustrates some things you can do with duck types that you can't with static types (unless you add in casting, see \nCasting Types\n).\n\n\nstatic1 as int  //type is fixed to be an integer\ndynamic1 as duck //can be anything\n\nstatic1 = 0\ndynamic1 = 0\nprint static1+1 //-\n 1\nprint dynamic1+1 //-\n 1\n\n#static1 = \nSome string\n //error, cannot convert string to int\ndynamic1 = \nSome string\n //dynamic1 can be \nany\n type of thing\n\n#print static1.ToUpper() //error, static1 is an int, not a string\nprint dynamic1.ToUpper() //-\n SOME STRING\n\n//You can convert a static type to a dynamic duck type:\ndynamic2 as duck = static1\nprint dynamic2 //-\n 0\ndynamic2 = \nSome string\n\nprint dynamic2.ToUpper() //-\n SOME STRING\n\n//or convert a dynamic type to a static type\nstatic2 as string = dynamic1\nprint static2.ToUpper()\n\n#static3 as int = dynamic1 //error, cannot cast string to int\n#print static3 + 2\n\n\n\n\nIf it helps, whenever you see \"duck\", think \"any\" or \"anything\". That object can be anything, and I can do whatever to it since it is duck typed and not static typed.\n\n\nA Practical Example: Automating Internet Explorer via COM Interop\n\n\nimport System.Threading\n\ndef CreateInstance(progid):\n   type = System.Type.GetTypeFromProgID(progid)\n   return type()\n\nie as duck = CreateInstance(\nInternetExplorer.Application\n)\nie.Visible = true\nie.Navigate2(\nhttp://www.go-mono.com/monologue/\n)\n\nThread.Sleep(50ms) while ie.Busy\n\ndocument = ie.Document\nprint \n$(document.title) is $(document.fileSize) bytes long.\n\n\n\n\n\nSee also how the example would look \nwithout duck typing\n.\n\n\nImplicit Duck Typing Option (-ducky)\n\n\nYou can replace \"ie as duck\" in the internet explorer example with \"ie\" and still have it run if you turn on the implicit duck typing option. See also the examples in the \ntests/testcases/ducky/\n folder.\n\n\nYou can set this option in various ways depending on which tool you are using:\n\n For the booi.exe and booc.exe command line tools, add a \"-ducky\" option when running those tools on the command line.\n\n In the Boo \nInteractive Interpreter\n, implicit duck typing is turned on by default. You can turn it off by typing \"interpreter.Ducky = false\".\n* In the \nBoo AddIn For SharpDevelop\n its off by default, but you'll see a \"duck typing by default\" option by selecting from the menu Project -\n Project Options, selecting the Compiling tab, and then clicking on the configurations for your debug and release builds.\n\n\nWhat this option does is basically make anything that is of type \"object\" be of type \"duck\" instead.\n\n\nTurning on the ducky option allows you to more quickly test out code, and makes coding in boo feel much more like coding in Python. However, it slows down the speed of your application due to not using static typing. So when you are done testing, you may wish to turn the ducky option back off and add in various type declarations and casts. See \nCasting Types\n.\n\n\nRegular \nType Inference\n is still in effect even when the ducky option is turned on, so if you declare \"x = 4\", then x is still an int. This allows your code to still be convertible to run without the ducky option by adding in the appropriate type declarations and casts.\n\n\nAdvanced: intercept duck typed method calls using IQuackFu\n\n\nSee\n\n\n\n\nDynamic Inheritance - fun with IQuackFu\n\n\nduck-5.boo\n\n\nXmlObject.boo\n\n\n\n\nThe -ducky option now automatically treats any class that implements the IQuackFu interface as a duck type too.\n\n\nCLS Compliance\n\n\nYour compiled assembly will still be CLS compliant (usable from other languages) if you use duck types. \"Duck\" is only a virtual type during the compile process. Duck types are converted into regular, CLS-compliant \"object\" types in the assembly. Again, see what the IE example looks like \nwithout duck typing\n to get an idea of how the compiler converts your code. Also, IQuackFu is a regular interface. Not special at all except to the boo compiler.", 
            "title": "Duck Typing"
        }, 
        {
            "location": "/Guide/Callable-Types/", 
            "text": "Callable types are a generalization of the concept of a \ndelegate\n in the CLI.\n\n\nIn boo, not only delegates and methods can be called as functions but also any object references of type \nSystem.Type\n or any \nBoo.Lang.ICallable\n implementing type.\n\n\nIn the case of System.Type references, the appropriate constructor will be called, if any. In the case of ICallable: ICallable.Call will.\n\n\nThe language itself allows new callable types to be formally defined through the callable construct:\n\n\ncallable MyCallable(param1 as int, param2) as bool\n\n\n\n\nThe example above defines a callable type which takes two arguments of types System.Int32 and System.Object respectively and returns a System.Bool value.\n\n\ncallable AnotherCallable(param)\n\n\n\n\nThis example defines a callable type which takes a single argument of type System.Object but has no return value.\n\n\ncallable UseCallable(c as AnotherCallable)\n\n\n\n\nThis last one defines a new callable type taking another callable type as its single argument with no return value.\n\n\nThe language allows free interchange of structurally compatible callable references. A callable is considered structurally compatible to a callable reference if the type of the reference is System.Object, Boo.Lang.ICallable or another callable type declaring the same number of arguments or less and all arguments types are also compatible.\n\n\nFor this scheme to work the compiler needs to implement some automatic conversion rules:\n\n\n\n t as Type =\n ICallable \n\n\n Boo.Lang.RuntimeServices.CallableType(t) \n\n\n\n\n\n\n Method reference =\n ICallable or System.Object \n\n\n new instance of a private ICallable implementation that takes original object reference (if any) in the constructor and calls the apropriate method in ICallable.Call \n\n\n\n\n\n\n x as CallableX =\n y as CallableY \n\n\n\n\nSee Also:\n\n\nEvents\n, \nFunctions\n, \nParameters", 
            "title": "Callable Types"
        }, 
        {
            "location": "/Guide/Events/", 
            "text": "Creating an Event\n\n\nWhat's that timmy? You're exposing your API to someone else, and they want convient handy-dandy events?! No problem! As with everything in Boo, its dead simple to get up and running within moments with the event keyword.\n\n\nimport System\n\nclass Clicker:\n    event Clicked as EventHandler\n    def RaiseClick():\n        Clicked(self, null)\n\n\n\n\nAww, yeah! Now you can use it like any other event!\n\n\np = Clicker()\np.Clicked += def(sender, args):\n    print \nTah CLICKED!\n\np.RaiseClick()\n\n\n\n\n(it prints out \"Tah CLICKED!\" if you're curious)\n\n\nBy now you're probably wondering what \"EventHandler\" is. In .NET, they are commonly referred to as delegates, a type of event that can be subscribed to by multiple functions, as long as each function has the same method signature as the delegate. An \"event\" is a special kind of delegate that has some rules:\n\n\nIt can't be called from outside its declaring class.\nThis keeps sneaky coders from invoking an event from somewhere else and potentially messing things up. Leaky boats are bad!\n\n\nSuppose, though, you want a ham sandwich on rye, or you want to expose a unique kind of event that has its own unique arguments. Here's another code sample to whet your appetite:\n\n\nimport System\n\nclass Sandwich:\n    //object - sandwich eaten.\n    //bool - if there are leftovers.\n    event Eaten as callable(object, bool)\n    //The two codes of line below are\n    //the equivilent of the one line of code above!\n    event Eating as EatingEvent\n    //object -- sandwiich being eaten.\n    //string -- the kind of sammich being eaten.\n    callable EatingEvent(sammich as object, type as string)\n\n    def Eat():\n        Eating(self, \nTurkey sammich.\n)\n        Eaten(self, false)\n\nturkeyAndSwiss = Sandwich()\nturkeyAndSwiss.Eating += def(obj, sammich):\n    print \nYou're eating a $sammich! It must be good.\n\nturkeyAndSwiss.Eaten += def(obj, leftovers):\n    print \nYou\n, (\ndidn't leave me anything?!\n,\nleft leftovers! How sweet!\n)[leftovers]\nturkeyAndSwiss.Eat()\n\n\n\n\nSee Also\n:\n\n\nCallable Types\n, \nFunctions\n, \nParameters\n, \nEvents", 
            "title": "Events"
        }, 
        {
            "location": "/Guide/Structs/", 
            "text": "Value types in boo are like value types in C# and include int, double, and other basic types. User-defined value types can be created in boo by defining a \nstruct\n or inheriting from \nSystem.ValueType\n.\n\n\nValue types are constructed on the stack rather than the heap as objects are. This makes them faster to create and dispose of, and they don't need to be garbage collected. User-defined value types can have methods and fields, just like classes. Value types cannot inherit from other types (exception - all value types inherit from System.ValueType, which itself inherits from object), and other types cannot inherit from value types. Value types can implement interfaces.\n\n\nHere's an example showing the implementation of a \nPoint\n value type by inheriting from System.ValueType.\n\n\nimport System\n\nclass Point(ValueType):\n    public X as int\n    public Y as int\n\np1 = Point(X: 200, Y: 300)\np2 = p1 # value type semantics means this creates a copy\n\np1.X = 250\nassert 200 == p2.X # copy still unchanged\n\n\n\n\nWhen \np1\n is assigned to \np2\n, the contents of \np1\n are physically copied to \np2\n. If \nPoint\n were a class (classes are reference types), the assignment would simply copy a pointer to \np1\n into \np2\n and the assertion would fail.\n\n\nHere's the equivalent definition for Point implemented using \nstruct\n:\n\n\nimport System\n\nstruct Point:\n    X as int\n    Y as int\n\n\n\n\nNote that by default, fields are public in a struct.", 
            "title": "Structs"
        }, 
        {
            "location": "/Guide/Literals/", 
            "text": "Array literals\n\n\nArrays are statically sized homogeneous data structures.\n\n\nl = (,) // empty array (typed (object))\nl = (1, 2, 3) // integer array with three elements\nl = (\nEric\n, ) // string array with a single element\n\n\n\n\nList literals\n\n\nLists are dynamically sized heterogeneous data structures.\n\n\nl = [] // empty list\nl = [\none\n, 2, 3]\n\n\n\n\nHash literals\n\n\nAlso known as associative arrays or dictionaries.\n\n\nh = {} // empty hash\nh = { \nspam\n : \neggs\n }\nprint h[\nspam\n]\n\n\n\n\nTimespan Literals\n\n\nprint 50s // 50 seconds\nprint 1d // 1 day\nprint 2m // 2 minutes\nprint 42ms // 42 miliseconds\n\nprint \nTomorrow this time will be: $(date.Now + 1d)\n\n\n\n\n\nRegular Expressions\n\n\nfname, lname = /(\\w+)/.Matches(\n Eric Idle \n)\nprint fname\nprint lname\n\n\n\n\nExtended regular expressions can also contain white space and tab characters but they \nmust\n be started by the \n@/\n sequence:\n\n\nfname, lname = @/ /.Split(\nEric Idle\n)\nprint fname\nprint lname", 
            "title": "Literals"
        }, 
        {
            "location": "/Guide/Lists-and-Arrays/", 
            "text": "Lists\n\n\nLists are mutable sequences of items. They are similar to lists in Python.\n\n\nLists are surrounded by brackets, just like python: [1,2,3]\n\n\nHere is some sample code demonstrating different operations you can do on lists:\n\n\n//the \nas List\n is optional:\nmylist as List = [\nfoo\n, \nbar\n, \nbaz\n, 0, 1, 2]\nprint mylist\n\nfor item in mylist:\n    print item\n\nprint \nlen(mylist): \n + len(mylist)\n\nfor i in range(mylist.Count):\n    print mylist[i]\n\n\nprint mylist.Join(\n=\n) //foo=bar=baz=0=1=2\n\nmylist[1] = \nbbb\n //set 2nd item\nprint mylist\nprint \nmylist[1]: \n + mylist[1] //print 2nd item\nprint \nIndex of \\\nbbb\\\n: \n + mylist.IndexOf(\nbbb\n)\nmylist.Add(\nnew item\n) //also mylist.Push does same thing\nprint mylist\nmylist.Insert(4,\nabc\n) //insert \nabc\n at 5th spot\nprint mylist\nmylist.Remove(\nbbb\n) //remove the \nbbb\n item\nprint mylist\nmylist.RemoveAt(1) //remove the 2nd item\nprint mylist\nmylist.Remove(0) //remove the zero item (not 1st item)\nprint mylist\nmylist += [\ntest\n]\nprint mylist\nmylist.Extend([\none\n,\ntwo\n])\nprint mylist\nlastitem = mylist.Pop() //removes last item from list and returns it\nprint mylist\n\nif mylist == [\nfoo\n,\nabc\n,1,2,\nnew item\n,\ntest\n,\none\n]:\n    print \nequals other list\n\n\n//List comprehensions:\nprint \njust the string items: \n + [i for i in mylist if i isa string]\nprint \njust the int items:    \n + [i for i in mylist if i isa int]\n//\ni isa string\n is the same as \ni.GetType() == string\n\n\n//another way to do it using the \nas\n cast: (see Casting Types)\n//   (i as string) will be null if item is an integer\nprint \njust the string items: \n + [stritem for i in mylist\n                    if stritem=(i as string)]\nprint \njust 3 letter items:   \n + [stritem for i in mylist\n                    if stritem=(i as string)\n                    and len(stritem) == 3]\n\nif \nfoo\n in mylist:\n    print \nfoo is in mylist\n\n\n//another way to do the same thing:\nif mylist.Contains(\nfoo\n):\n    print \ncontains foo\n\n\nif \nbaditem\n not in mylist:\n    print \nbaditem is not in mylist\n\n\n//You can also pass a special search function or closure to Find.\n//Find returns the first item that returns true from the search function.\nif mylist.Find({item | return item == \nfoo\n}):\n    print \nfound foo\n\n\n//using a multiline do/def closure with Find:\nresult = [1, 2, 3].Find() do (item as int):\n        return item \n 1\nprint \nitem \n 1 in [1,2,3]: \n + result\n\n//Collect is similar to Find but it returns a list of all items that\n//return true from the search function.\nresult = [1, 2, 3].Collect() do (item as int):\n        return item \n 1\nprint \nall items \n 1 in [1,2,3]: \n + result\n\n//Sorting a list.  Only works if all the items are comparable\n//(all ints or strings for example)\n//or if you pass your own compare function.\nnewlist =  [2, 4, 3, 5, 1]\nprint newlist\nprint newlist.Sort()\nresult = newlist.Sort() do (left as int, right as int):\n    return right - left //reverse sort order\nprint result\n\nmylist = mylist * 3\nprint mylist\n\nmylist.Clear()\n\n\n\n\nArrays\n\n\nArrays are similar to arrays in C, C#, or Java. They are initialized to a certain fixed length, and all the items in an array are generally of the same type (int, string, etc.).\n\n\nIn boo, arrays use parentheses to surround the items instead of brackets: (1,2,3).\n\n\nIf you need to declare the type of an array, use parentheses surrounding the type of item in the array, such as (int) for an array of ints or (object) for an array of objects.\n\n\nBoo's arrays and lists are zero-based, so the first item is item 0, the 2nd is item 1, etc.\n\n\n//Create an array with 3 strings - the 'as (string)' part is optional\nmyarray as (string) = (\none\n, \ntwo\n, \nthree\n)\nfor i in myarray:\n    print i\n\n//Create an array to hold 10 integers:\na as (int) = array(int,10)\n//set the 2nd item to 3\na[1] = 3\nprint a[1]\n\n//Convert from array to list:\nmylist = [item for item in myarray]\nprint mylist\n\n//Convert from list back to array:\n\n//This is the preferred way to do it:\narray2 = array(string, mylist)\n\n//but there is this way too: (compiler can't tell the type though)\narray3 = mylist.ToArray(string)\nfor i in array2:\n    print i\n\n// Append two arrays:\na = (1, 2) + (3, 4)\nassert a == (1, 2, 3, 4)\n\n\n\n\nByte Arrays and Char Arrays\n\n\nCreating byte arrays - arrays of type (byte).\n\n\nBoo right now doesn't support implicitly converting int literals to type byte, so you need to use the array() builtin function.\n\n\n#won't work: bytes as (byte) = (1,2,3,4,5)\n\n//int to byte\nbytes = array(byte,(1,2,3,4,5))\n\nprint bytes.GetType() //-\n System.Byte[]\n\nfor b in bytes:\n    print b\n\n//hex literals to byte\nbytes = array(byte, (0xFF, 0xBB, 0x3F))\nfor b in bytes:\n    print b\n\n//chars or string to a byte array:\nbytes = System.Text.ASCIIEncoding().GetBytes(\nabcABC\n)\nfor b in bytes:\n    print b\n\n\n\n\nChar arrays - arrays of type (char).\n\n\nBoo also right now doesn't have support for implicitly converting single character string literals (like \"a\") to the char type. A workaround it to use slicing (\"a\"0), but in this case you can use the ToCharArray method of the string class instead:\n\n\n#won't work: charbytes as (char) = (\na\n, \nb\n, \nc\n)\n\n//String.ToCharArray()\ncharbytes = \nabcABC\n.ToCharArray()\n\nprint charbytes.GetType() //-\n System.Char[]\n\nfor b in charbytes:\n    print b\n\n\n\n\nCreating an empty, zero-length array\n\n\nSometimes a system function might require passing an array even if it is empty. Here are some ways to create an empty zero-length array of type (object):\n\n\nemptyArray = array(object, 0)\n\n//other ways:\nemptyArray = array(object,[])\nemptyArray = [].ToArray(object)\nemptyArray = array([])\n\n//If the type is to be (object), then you can simply use:\nemptyArray = (,)\n\n\n\n\nSlicing Lists and Arrays\n\n\nYou can also \"slice\" lists and arrays to get a particular subset of a list or array.\n\n\nMultidimensional Arrays\n\n\nRecently boo added support for \nMultidimensional Arrays\n, also called rectangular arrays.", 
            "title": "Lists and Arrays"
        }, 
        {
            "location": "/Guide/Multidimensional-Arrays/", 
            "text": "When declaring a variable or a field as a multidimensional array, use this syntax:\n\n\nfoo as (int, 3) //declare a 3 dimensional array of integers.\n\n\n\n\nWhen creating a brand spanking new multidimensional array, use this syntax:\n\n\nfoo = matrix(int, 2, 3, 4)\n//That creates an empty 3 dimensional array.\n//1st dimension will have 2 items, 2nd has 3, 3rd has 4\n\n\n\n\nSet and retrieve data from the array:\n\n\nfoo[0,0,1] = 100\nprint foo[0,0,1]\n\n\n\n\nThis shows looping over the array to set or get values:\n\n\nn = 1\nfor i in range(len(foo,0)): //# of items in 1st dimension\n    for j in range(len(foo,1)): //2nd dimension\n        for k in range(len(foo,2)): //3rd dimension\n            foo[i,j,k] = n\n            ++n\n\n//Print the values out in a table format:\ncolumns = len(foo, foo.Rank - 1)\nline = []\nfor item in foo:\n    line.Add(item.ToString(\n00\n))\n    if len(line) \n= columns:\n        print join(line)\n        line.Clear()\n\n\n\n\nThe whole code together produces this output:\n\n\n100\n01 02 03 04\n05 06 07 08\n09 10 11 12\n13 14 15 16\n17 18 19 20\n21 22 23 24\n\n\n\n\nSee also \nLists and Arrays\n. \nSlicing\n works for multidimensional arrays too.", 
            "title": "Multidimensional Arrays"
        }, 
        {
            "location": "/Guide/Hashtables/", 
            "text": "Hashtables (also called dictionaries, maps, or associative arrays) are data structures that allow you to store named items. They are similar to Python's dictionaries. For example:\n\n\nd = {\nfoo\n : \nbar\n, \nspam\n : \neggs\n}\n\nprint d[\nfoo\n]  //prints \nbar\n\n\nemptydict = {}\n\nprint d.GetType() //-\n Boo.Lang.Hash\n\n\n\n\nBoo's hash class is defined in Boo.Lang.Hash, which is a subclass of the standard \nSystem.Collections.Hashtable\n class. See that page for more documentation about the methods and properties that boo's hashtable inherits.\n\n\nIf you haven't already, you should learn about \nLists and Arrays\n also.\n\n\nHere is a sample of things you can do with a dictionary:\n\n\nd = {\nfoo\n : \nbar\n, \nspam\n : \neggs\n}\n\nprint \nd has $(d.Count) items\n\n\n//add a new item:\nd[\ntest\n] = \nnew item\n\n\nprint \nd has ${d.Count} items\n\n\n//change an existing item\nd[\nfoo\n] = \nbarbar\n\n\n//print everything in the dictionary\nfor item in d:  //item is of type System.Collections.DictionaryEntry\n    print item.Key, \n:\n, item.Value\n\n//an alternative way\nfor key in d.Keys:\n    print key, \n-\n, d[key]\n\nif d.ContainsKey(\nfoo\n):\n    print \nhas key foo\n\n\nif d.ContainsValue(\neggs\n):\n    print \nhas value eggs\n\n\n//get the first key: (have to explicitly convert to an array)\nprint \nfirst key:\n, array(d.Keys)[0]\n\n//print the first value\nprint \nfirst value:\n, array(d.Values)[0]\n\n//convert hash to a jagged array like python's dictionary.items:\nitems = array((item.Key, item.Value) for item in d)\n//(('spam', 'eggs'), ('foo', 'barbar'), ('test', 'new item'))\n\n\n//Remove an item:\nd.Remove(\ntest\n)\n\n\n//Getting a default value if the key is not found:\n//This works because d[\nbadkey\n] will return null\nitem = d[\nbadkey\n] or \ndefault value\n\n\n\n\n\nSee also \nLists and Arrays", 
            "title": "Hashtables"
        }, 
        {
            "location": "/Guide/Slicing/", 
            "text": "A slicing operation is a simple way to extract a range of elements from a container. The boo compiler supports native slicing operations on lists, arrays and strings. Support for user defined slicing operations is planned but currently not implemented.\n\n\nGeneral Syntax\n\n\nA slicing operation is applied to a container through the following syntax:\n\n\nrange = container[\nfirstIndexWanted\n : \nfirstIndexNotWanted\n : \nstep\n]\n\n\n\n\nWhen \nfirstIndexWanted\n is omitted it is assumed to be 0.\n\n\nWhen \nfirstIndexNotWanted\n is omitted it is assumed to be equals to len(container).\n\n\nWhen \nstep\n is omitted it is assumed to be 1.\n\n\nList Slicing\n\n\n\nl = [1, 2, 3, 4]\nassert l[0] == 1\nassert l[0:1] == [1]\nassert l[0:2] == [1, 2]\nassert l[1:3] == [2, 3]\nassert l[:] == [1, 2, 3, 4]  // easy way to clone a list\n\n\n\n\nArray Slicing\n\n\na = (1, 2, 3, 4)\nassert a[0:1] == (1,)\nassert a[:3] == (1, 2, 3)\nassert a[:2] == (1, 2)\n#assert a[::2] == (1, 3)      #Slicing step not implemented yet\n#assert a[-2:-1:-1] == (4, 3) #ditto\n\n\n\n\nString Slicing\n\n\ns = \nbamboo\n\nassert \nb\n == s[0:1]\nassert \nboo\n == s[3:]\nassert \nbo\n == s[3:-1]\n\n\n\n\nDifferences Between Collection Types\n\n\nConsider the following example:\n\n\nprint([1, 2, 3].GetType()) // will print \nBoo.Lang.List\n\nprint((4, 5, 6).GetType()) // will print \nSystem.Int32[]\n\nprint((\n1\n, \n2\n, 3).GetType()) // will print \nSystem.Object[]\n\nprint((\na\n, \nb\n).GetType()) // will print \nSystem.String[]\n\nprint([\nfoo\n, \nbar\n].GetType()) // will print \nBoo.Lang.List\n\n\n\n\n\nYou must specify a parameter is a sliceable type when using it with methods:\n\n\n// This code will NOT compile\nclass Test:\n    def example(itens):\n        i = 0\n        itensLen = len(itens)\n        while i \n itensLen:\n            print (itens[i])\n            ++i\n\nt = Test()\nt.example([1, 2, 3, 4, 5])\n\n\n\n\nthe above code will result on compile time error The type 'System.Object' does not support splicing'. This is because the boo compiler cannot predict that you want to pass a collection to the method, and since the type Object is neither a collection or array, we got the error. To handle that, explicitly tell the compiler that you will pass a collection to the method:\n\n\n// This code WILL compile\nimport System.Collections\n\nclass Test:\n    def example(itens as IList):\n        i = 0\n        itensLen = len(itens)\n        while i \n itensLen:\n            print (itens[i])\n            ++i\nt = Test()\nt.example([1, 2, 3, 4, 5])", 
            "title": "Slicing"
        }, 
        {
            "location": "/Guide/Classes/", 
            "text": "Here's an example illustrating some of the basics about classes.\n\n\nUntil more documentation is here, for examples of using classes, see the \nclasses-\n.boo files under\n\ntests/testcases/integration/types\n,\nas well as \nsuper-\n.boo, \nabstract-\n.boo, \ninterfaces-\n.boo, \nbaseclass-\n.boo, \ninnerclasses-\n.boo, \nfields-\n.boo,\nand \nproperties-\n.boo.\n\n\ninterface IAnimal:\n    Name as string:\n        get\n\n    Legs as int:\n        get\n\n    def Eat(food)\n\nclass Dog(IAnimal):\n    Name:\n        get:\n            return \nCanine\n\n\n    Legs:\n        get:\n            return 4\n\n    def Eat(food):\n         if food isa IPlant:\n                Speak()\n\n    def Speak():\n         print \nbark!\n\n\ninterface IPlant:\n    pass\n\nclass Rice(IPlant):\n    pass\n\n//////////////////////////\n\nd = Dog()\n\nprint \n$(d.Name) has $(d.Legs) legs.\n\n\nr = Rice()\nd.Eat(r)", 
            "title": "Classes"
        }, 
        {
            "location": "/Guide/Fields-and-Properties/", 
            "text": "Fields and properties are used to store and control access to data (integers, strings, etc.) inside a class.\n\n\nFields store the values, and by default are \"protected\", they can only be accessed from methods inside the\nclass (or a subclass). You can declare a field as \"public\", however (see example code below).\n\n\nProperties are similar to fields, except that you define a getter and a setter method that are called when\none tries to retrieve the value of the property or set the value of the property. This is useful for example\nif you want to check the value before setting it, or making a read-only property. The default access level\nof properties is \"public\".\n\n\nHere is some code demonstrating different kinds of fields and properties:\n\n\nclass MyClass:\n    //a field, initialized to the value 1\n    regularfield as int = 1 //default access level: protected\n\n    //a string field\n    mystringfield as string = \nhello\n\n\n    //a private field\n    private _privatefield as int\n\n    //a public field\n    public publicfield as int = 3\n\n    //a static field: the value is stored in one place and shared by all\n    //instances of this class\n    static public staticfield as int = 4\n\n    //a property (default access level: public)\n    RegularProperty as int:\n        get: //getter: called when you retrieve property\n            return regularfield\n        set: //setter: notice the special \nvalue\n variable\n            regularfield = value\n\n    ReadOnlyProperty as int:\n        get:\n            return publicfield\n\n    SetOnlyProperty as int:\n        set:\n            publicfield = value\n\n    //a field with an automatically generated property\n    [Property(MyAutoProperty)]\n    _mypropertyfield as int = 5\n\n    //constructor is called when you create a new MyClass instance\n    // like so:   m = MyClass()\n    def constructor():\n        _privatefield = 3\n\n    //another constructor would let you pass a value to the class\n    //when creating it:  m = MyClass(33)\n    def constructor(fieldvalue as int):\n        _privatefield = fieldvalue\n\nm = MyClass()\n//print m.regularfield //error: field has protected access\nprint m.publicfield\nm.publicfield = 10\nprint m.publicfield\nprint m.staticfield\nprint MyClass.staticfield //another way to access static values\nprint m.RegularProperty\nm.RegularProperty = 100\nprint m.RegularProperty\n\n//this was the automatically created property\nprint m.MyAutoProperty\nm.MyAutoProperty = 11\n\nprint m.ReadOnlyProperty\n//m.ReadOnlyProperty = 333 //error: only has getter, no setter\n\n//print m.SetOnlyProperty //error: only has setter\nm.SetOnlyProperty = 555\n\n\n\n\nRead-only and Constant Fields\n\n\nUse the \"final\" keyword to create a field that cannot be modified. This is similar to\n\"readonly\" in C#. The value of the field is set only once when a class is instantiated\n(the constructor is called). If you mark a field \"static final\", then the value is\nhard-coded at compile time. This is similar to \"const\" in C#.\n\n\nclass C:\n    final A = 2  //like \nreadonly in C#, value set when class instantiated\n    final B as int  //you can set this value yourself just once in the constructor\n\n    static final B = 3 //like \nconst\n in C#\n\n\n\n\nMore Info\n\n\nTo better understand properties and fields in boo, you may find it helpful to search\nfor information on properties and fields in C# and Visual Basic .NET, such as these resources:\n\n\n\n\nhttp://www.csharp-station.com/Tutorials/Lesson10.aspx\n\n\nhttp://www.c-sharpcorner.com/Language/PropertiesInCSRVS.asp\n\n\nhttp://msdn.microsoft.com/en-us/library/x9fsa0sw%28v=VS.100%29.aspx", 
            "title": "Fields and Properties"
        }, 
        {
            "location": "/Guide/Interfaces/", 
            "text": "Interfaces are introduced thru the interface keyword:\n\n\ninterface IFoo:\n   pass\n\n\n\n\nInterface methods don't need to have a body:\n\n\ninterface IUnknown:\n    def QueryInterface(id as System.Guid) as object\n\n\n\n\nBut if they do it must be empty:\n\n\ninterface IFoodMachine:\n    def Spam():\n        pass\n\n\n\n\nIf a method in a interface does not declare a return type it is assumed to be void since there's no body with a return statement where to infer the type from. Thus the above interface declaration is equivalent to the following one:\n\n\ninterface IFoodMachine:\n    def Spam() as void\n\n\n\n\nInterfaces can extend other interfaces:\n\n\ninterface ImALumberjackAndImOk:\n    def SleepAllNight()\n    def WorkAllDay()\n\ninterface IWishIdBeenAGirlie(ImALumberjackAndImOk):\n    def JustLikeMyDearPappa()\n\n\n\n\nInterfaces can be partial:\n\n\npartial interface I:\n    def Foo()\n\npartial interface I:\n    def Bar()\n\nfor member in typeof(I).GetMembers():\n    print member.Name", 
            "title": "Interfaces"
        }, 
        {
            "location": "/Guide/Operator-Overloading/", 
            "text": "Boo has operator overloading. Overloaded operators must be defined as \nstatic\n. For example:\n\n\nstruct myNum:\n    i as double\n    def constructor(j as int):\n        i = j\n    static def op_Multiply(x as myNum, j as int):\n        x.i = x.i * j\n        return x\n    static def op_Multiply(x as myNum, y as myNum):\n        x.i = x.i * y.i\n        return x\n    static def op_Addition(x as myNum, j as int):\n        x.i = x.i + j\n        return x\n    static def op_Equality(x as myNum, y as double):\n        return x.i == y\n    static def op_UnaryNegation(x as myNum):\n        x.i = -x.i\n        return x\n    def ToString():\n        return i.ToString()\n\nx = myNum(5)\ny = -x*x*2 + 1\nassert y == -49\n\n\n\n\nThese binary operators can be overloaded:\n\n\nop_Addition\nop_Subtraction\nop_Multiply\nop_Division\nop_Modulus\nop_Exponentiation\nop_Equality\nop_LessThan\nop_LessThanOrEqual\nop_GreaterThan\nop_GreaterThanOrEqual\nop_Match\nop_NotMatch\nop_Member\nop_NotMember\nop_BitwiseOr\nop_BitwiseAnd\n\n\n\n\nWhen you overload a binary arithmetic operator such as op_Addition, the corresponding assignment operator ( += ) is overloaded too.\n\n\nThis unary operator can be overloaded:\n\n\nop_UnaryNegation", 
            "title": "Operator Overloading"
        }, 
        {
            "location": "/Guide/Enums/", 
            "text": "The keyword enum introduces an enumerated type, a set of name to integer value associations.\n\n\nenum Python:\n     Eric\n     John\n     TerryG\n     TerryJ\n     Graham\n     Michael\n\n\n\n\nwhich is equivalent to:\n\n\nenum Python:\n     Eric = 0\n     John = 1\n     TerryG = 2\n     TerryJ = 3\n     Graham = 4\n     Michael = 5\n\n\n\n\nExtracting the integer value of a enum is just a matter of casting it to an int:\n\n\nprint((Python.TerryG cast int)*2)\u00a0# prints 4\n\n\n\n\nIt's possible to define partial enums:\n\n\npartial enum E:\n    Foo\n\npartial enum E:\n    Bar\n\nfor value in System.Enum.GetValues(E):\n    print value, \n=\n, value cast int", 
            "title": "Enums"
        }, 
        {
            "location": "/Guide/Macros/", 
            "text": "Print\n\n\nprint\n\n\nSystem.Console.WriteLine()\n\n\n\n\nprint \n\n\nSystem.Console.WriteLine(\nexpr\n)\n\n\n\n\nprint \n, [... ,] \n\n\nSystem.Console.Write(\nexpr\n)\nSystem.Console.Write(' ')\n ...\nSystem.Console.WriteLine(\nexprN\n)\n\n\n\n\nassert\n\n\nassert \n\n\nunless (\nexpr\n):\n    raise Boo.AssertionFailedException('(\nexpr\n)')\n\n\n\n\nassert \n, \n\n\nunless (\nexpr\n):\n    raise Boo.AssertionFailedException(\nstring\n)\n\n\n\n\nusing\n\n\nusing:\n    \n\n\ntry:\n    \nblock\n\nensure:\n    pass\n\n\n\n\nusing \n [, ...]:\n    \n\n\ntry:\n    \nblock\n\nensure:\n    if (__disposable__ = (\nobject\n as System.IDisposable)):\n        __disposable__.Dispose()\n        __disposable__ = null\n    ...\n\n\n\n\nusing \n = \n [, ...]:\n    \n\n\ntry:\n    __using1__ = \nexpr\n\n    ...\n    \nblock\n\nensure:\n    if (__disposable__ = (__using1__ as System.IDisposable)):\n        __disposable__.Dispose()\n        __disposable__ = null\n    ...\n\n\n\n\nlock\n\n\nlock \n [, ...]:\n    \n\n\n_monitor1__ = \nexpr\n\nSystem.Threading.Monitor.Enter(__monitor1__)\ntry:\n    \nblock\n\nensure:\n    System.Threading.Monitor.Exit(__monitor1__)\n\n\n\n\ndebug\n\n\ndebug\n\n\nSystem.Diagnostics.Debug.WriteLine('\ndebug\n')\n\n\n\n\ndebug \n\n\nSystem.Diagnostics.Debug.WriteLine(\nexpr\n)\n\n\n\n\ndebug \n, [... ,] \n\n\nSystem.Diagnostics.Debug.Write(\nexpr\n)\nSystem.Diagnostics.Debug.Write(' ')\n ...\nSystem.Diagnostics.Debug.WriteLine(\nexprN\n)", 
            "title": "Macros"
        }, 
        {
            "location": "/Guide/Syntactic-Macros/", 
            "text": "Syntactic macros allow new language constructs to be created.  See \nMacros\n for a list of existing ones in boo.\n\n\nWe could, for example, mimic VisualBasic's with statement.\n\n\nGiven the following code\n\n\nfooInstanceWithReallyLongName = Foo()\nfooInstanceWithReallyLongName.f1 = 100\nfooInstanceWithReallyLongName.f2 = \nabc\n\nfooInstanceWithReallyLongName.DoSomething()\n\n\n\n\nIf we define a 'with' macro we could rewrite it like this:\n\n\nwith fooInstanceWithReallyLongName:\n    _f1 = 100\n    _f2 = \nabc\n\n    _DoSomething()\n\n\n\n\nIn boo, macros are CLI objects that implement the Boo.Lang.Compiler.IAstMacro interface. It is interesting to note that there is nothing magic about these objects. They must simply implement the interface the compiler expects. This implies that boo macros can be written in any CLI language!\n\n\nWhen an unknown syntactic structure is encountered at compile time, like the with statement above, the compiler will look for the correct IAstMacro class, create an instance, and ask that instance to expand the macro. The compiler identifies the class to use via a simple naming convention. The class name must start with the name of the macro and end with 'Macro'. Additionally the \nPascal case\n naming convention must be used. So in this case the name must be 'WithMacro'.\n\n\nHere's the code to implement our macro:\n\n\n\nimport Boo.Lang.Compiler\nimport Boo.Lang.Compiler.Ast\nimport Boo.Lang.Compiler.Ast.Visitors\n\nclass WithMacro(AbstractAstMacro):\n\n    private class NameExpander(DepthFirstTransformer):\n\n        _inst as ReferenceExpression\n\n        def constructor(inst as ReferenceExpression):\n            _inst = inst\n\n        override def OnReferenceExpression(node as ReferenceExpression):\n            // if the name of the reference begins with '_'\n            // then convert the reference to a member reference\n            // of the provided instance\n            if node.Name.StartsWith('_'):\n                // create the new member reference and set it up\n                mre = MemberReferenceExpression(node.LexicalInfo)\n                mre.Name = node.Name[1:]\n                mre.Target = _inst.CloneNode()\n\n                // replace the original reference in the AST\n                // with the new member-reference\n                ReplaceCurrentNode(mre)\n\n    override def Expand(macro as MacroStatement) as Statement:\n        assert 1 == macro.Arguments.Count\n        assert macro.Arguments[0] isa ReferenceExpression\n\n        inst = macro.Arguments[0] as ReferenceExpression\n\n        // convert all _\nref\n to inst.\nref\n\n        block = macro.Block\n        ne = NameExpander(inst)\n        ne.Visit(block)\n        return block\n\n\n\n\nSome explanation is in order. The parsing stage of the compiler pipeline parses a source stream into an abstract syntax tree (AST). A subtree, corresponding to the macro, will be passed to the Expand() method. Expand() is responsible for building an AST that will replace the provided subtree.\n\n\nThe subtree corresponding to a macro statement is embodied by the MacroStatement parameter.\n\n\nA MacroStatement has a collection of arguments and a block.\n\n\nIn this case we expect a single argument: a reference to an object. We then traverse the block looking for references whose name begins with the '_' character. Whenever we encounter one, we replace it with a reference to a member.\n\n\nThere are two classes related specifically to AST traversal: DepthFirstVisitor and DepthFirstTransformer. Both classes walk an AST invoking appropriate methods for each type of element in the tree. In this case, we subclassed DepthFirstTransformer as a convenient way to find and replace ReferenceExpression nodes in the macro's block.\n\n\nYou can find this plus other macro examples in the \nexamples/macros directory\n.\n\n\nA \ncustom macro syntax\n is also planned.\n\n\nBuilt-in Macros\n\n\nSome other examples of macros already implemented in boo:\n\n\nprint \nhello!\n\n\nassert x == true\n\ndebug \nprint debug message\n\n\nusing file=File.OpenText(fname): //disposes of file when done\n    print(file.ReadLine())\n\no1 = object()\nlock o1:  //similar to \nsynchronized\n in java\n pass", 
            "title": "Syntactic Macros"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ\n\n\nFrequently asked questions. Have a question? Post it here or to one of our \nMailing Lists\n.\n\n\nLicense\n\n\nboo is licensed under a MIT/BSD style license. The current license is always \navailable here\n.\n\n\nHow complete is boo at the present moment? What's its current status?\n\n\nBoo is already usable for a large variety of tasks but there still are lots of things in our todo lists on \n GitHub\n and \nCodeHaus\n.\n\n\nPerformance: since it is statically typed, can I expect a performance equal or close to c# or vb.net?\n\n\nYes.\n\n\nHow different is it from Python?\n\n\nSee \nGotchas for Python Users\n for a summary.\n\n\nIs it feasable to use boo for building desktop or asp.net applications?\n\n\nYes. Boo can already be used to implement WinForms/GTK# applications. Take a look at the extras/boox folder for an example.\n\n\nOn the asp.net front, thanks to Ian it's already possible to directly embed boo code inside asp.net pages, handlers or webservices. \nexamples/asp.net\n should give you an idea of how everything works right now.\n\n\n(Sharp|Mono)Develop bindings?\n\n\nDaniel Grunwald has made great progress on the SharpDevelop front. Recent versions of SharpDevelop include solution creation in Boo.\n\n\nAs for MonoDevelop, it includes a Boo binding, written by Peter Johanson, leveraging the parser code written by Daniel Grunwald for the SharpDevelop binding. It includes Boo project creation/editing/compiling, as well as an interactive shell with Gtk# integration. See the \nmonodevelop page\n for more information on installing it.\n\n\nI see references on the site for .NET 1.1 and .NET 2.0, does Boo support .NET 3.0?\n\n\n.NET 3.0 is actually just an update to the framework and not to the CLR or any of the \"official\" languages. As such, it should be supported by any .NET-2.0-supporting language, such as Boo.\n\n\nAlso, Boo release .78 is the last version of Boo that will support .NET 1.1.\n\n\nWhat's a good way to get started with Boo (editors/IDEs)?\n\n\nFire up a console and check out booish - a built-in editor to check out the basics. Then grab a copy of Sharpdevelop or monodevelop to dive into developing with Boo.\n\n\nWhat do people use for building 'real' Boo applications?\n\n\nOn Windows, Sharpdevelop is the most robust and stable IDE for developing BOO applications. Linux and Mac users develop with their favorite text editor. The monodevelop team are hard at work developing a more professional development environment that will support Boo along with other .NET languages.\n\n\nWhen will version 1.0 be available?\n\n\nWhen Boo is written in Boo it will be dubbed version 1.0.\n\n\nTranslations\n\n\nThis article is translated to \nSerbo-Croatian\n by \nWHG Team\n.", 
            "title": "Faq"
        }, 
        {
            "location": "/faq/#faq", 
            "text": "Frequently asked questions. Have a question? Post it here or to one of our  Mailing Lists .  License  boo is licensed under a MIT/BSD style license. The current license is always  available here .  How complete is boo at the present moment? What's its current status?  Boo is already usable for a large variety of tasks but there still are lots of things in our todo lists on   GitHub  and  CodeHaus .  Performance: since it is statically typed, can I expect a performance equal or close to c# or vb.net?  Yes.  How different is it from Python?  See  Gotchas for Python Users  for a summary.  Is it feasable to use boo for building desktop or asp.net applications?  Yes. Boo can already be used to implement WinForms/GTK# applications. Take a look at the extras/boox folder for an example.  On the asp.net front, thanks to Ian it's already possible to directly embed boo code inside asp.net pages, handlers or webservices.  examples/asp.net  should give you an idea of how everything works right now.  (Sharp|Mono)Develop bindings?  Daniel Grunwald has made great progress on the SharpDevelop front. Recent versions of SharpDevelop include solution creation in Boo.  As for MonoDevelop, it includes a Boo binding, written by Peter Johanson, leveraging the parser code written by Daniel Grunwald for the SharpDevelop binding. It includes Boo project creation/editing/compiling, as well as an interactive shell with Gtk# integration. See the  monodevelop page  for more information on installing it.  I see references on the site for .NET 1.1 and .NET 2.0, does Boo support .NET 3.0?  .NET 3.0 is actually just an update to the framework and not to the CLR or any of the \"official\" languages. As such, it should be supported by any .NET-2.0-supporting language, such as Boo.  Also, Boo release .78 is the last version of Boo that will support .NET 1.1.  What's a good way to get started with Boo (editors/IDEs)?  Fire up a console and check out booish - a built-in editor to check out the basics. Then grab a copy of Sharpdevelop or monodevelop to dive into developing with Boo.  What do people use for building 'real' Boo applications?  On Windows, Sharpdevelop is the most robust and stable IDE for developing BOO applications. Linux and Mac users develop with their favorite text editor. The monodevelop team are hard at work developing a more professional development environment that will support Boo along with other .NET languages.  When will version 1.0 be available?  When Boo is written in Boo it will be dubbed version 1.0.  Translations  This article is translated to  Serbo-Croatian  by  WHG Team .", 
            "title": "FAQ"
        }
    ]
}